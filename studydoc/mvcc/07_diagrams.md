# MVCC 架构图表集

## 1. MVCC 整体架构图

```
PostgreSQL MVCC 多版本并发控制系统
=====================================

┌─────────────────────────────────────────────────────────────────┐
│                        应用层/SQL层                              │
│  INSERT / UPDATE / DELETE / SELECT 操作                          │
└────────────────────┬────────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────────┐
│                      事务管理器                                   │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │ 事务ID分配  │  │ 快照创建    │  │ 事务提交    │             │
│  │ (GetNewTxn) │  │(GetSnapshot)│  │(CommitTxn)  │             │
│  └─────────────┘  └─────────────┘  └─────────────┘             │
└────────────────────┬────────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────────┐
│                    MVCC 核心层                                    │
│                                                                   │
│  ┌────────────────────────────────────────────────────────┐     │
│  │               可见性判断引擎                            │     │
│  │  HeapTupleSatisfiesMVCC() / HeapTupleSatisfiesUpdate() │     │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐             │     │
│  │  │ t_xmin   │  │ t_xmax   │  │ Snapshot │             │     │
│  │  │ 检查     │  │ 检查     │  │ 对比     │             │     │
│  │  └──────────┘  └──────────┘  └──────────┘             │     │
│  └────────────────────────────────────────────────────────┘     │
│                                                                   │
│  ┌────────────────────────────────────────────────────────┐     │
│  │               元组版本链管理                            │     │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐             │     │
│  │  │ HOT链    │  │ CTID链   │  │ 死元组   │             │     │
│  │  │ 维护     │  │ 跟踪     │  │ 标记     │             │     │
│  │  └──────────┘  └──────────┘  └──────────┘             │     │
│  └────────────────────────────────────────────────────────┘     │
└────────────────────┬────────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────────┐
│                      存储层                                       │
│                                                                   │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │              堆表存储 (Heap Table)                       │    │
│  │  ┌──────────────────────────────────────────────┐       │    │
│  │  │ Page 1                                       │       │    │
│  │  │  ┌─────────────┐  ┌─────────────┐          │       │    │
│  │  │  │ Tuple v1    │  │ Tuple v2    │ ...      │       │    │
│  │  │  │ t_xmin=100  │  │ t_xmin=105  │          │       │    │
│  │  │  │ t_xmax=105  │  │ t_xmax=0    │          │       │    │
│  │  │  │ t_ctid=→v2  │  │ t_ctid=self │          │       │    │
│  │  │  └─────────────┘  └─────────────┘          │       │    │
│  │  └──────────────────────────────────────────────┘       │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                   │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │            CLOG (事务提交日志)                           │    │
│  │  ┌──────────────────────────────────────────────┐       │    │
│  │  │ XID → Status (COMMITTED/ABORTED/IN_PROGRESS) │       │    │
│  │  │  100 → COMMITTED                             │       │    │
│  │  │  105 → COMMITTED                             │       │    │
│  │  │  110 → IN_PROGRESS                           │       │    │
│  │  └──────────────────────────────────────────────┘       │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

## 2. 元组头部结构详解

```
HeapTupleHeaderData 结构 (共23字节头部)
========================================

字节偏移   字段名称         大小    说明
--------   ------------     ----    --------------------------------
0-3        t_xmin           4字节   插入该元组的事务ID
4-7        t_xmax           4字节   删除/更新该元组的事务ID (0表示未删除)
8-11       t_cid|t_xvac     4字节   命令ID 或 VACUUM操作的事务ID
12-17      t_ctid           6字节   当前或新元组的物理位置(BlockNumber+OffsetNumber)
18-19      t_infomask2      2字节   属性数量和标志位
20-21      t_infomask       2字节   各种标志位
22         t_hoff           1字节   元组头部长度

┌──────────────────────────────────────────────────────────────┐
│                    完整元组结构                               │
├──────────────────────────────────────────────────────────────┤
│  0: t_xmin (4B)        │  插入事务ID: 例如 100              │
├────────────────────────┼────────────────────────────────────┤
│  4: t_xmax (4B)        │  删除/更新事务ID: 例如 105 或 0   │
├────────────────────────┼────────────────────────────────────┤
│  8: t_cid (4B)         │  命令ID: 同一事务内的命令序号      │
├────────────────────────┼────────────────────────────────────┤
│ 12: t_ctid (6B)        │  (Block=3, Offset=5) 指向新版本   │
│     BlockNumber (4B)   │                                    │
│     OffsetNumber (2B)  │                                    │
├────────────────────────┼────────────────────────────────────┤
│ 18: t_infomask2 (2B)   │  HEAP_HOT_UPDATED=0x4000          │
│                        │  HEAP_ONLY_TUPLE=0x8000           │
│                        │  低11位=列数                       │
├────────────────────────┼────────────────────────────────────┤
│ 20: t_infomask (2B)    │  HEAP_XMIN_COMMITTED=0x0100       │
│                        │  HEAP_XMIN_INVALID=0x0200         │
│                        │  HEAP_XMAX_COMMITTED=0x0400       │
│                        │  HEAP_XMAX_INVALID=0x0800         │
│                        │  HEAP_UPDATED=0x2000              │
├────────────────────────┼────────────────────────────────────┤
│ 22: t_hoff (1B)        │  头部长度: 通常=23 或 24+         │
├────────────────────────┴────────────────────────────────────┤
│ 23+: NULL bitmap (可选)  每列1位，标记是否为NULL           │
├─────────────────────────────────────────────────────────────┤
│ t_hoff+: 用户数据        col1_data, col2_data, ...         │
└─────────────────────────────────────────────────────────────┘
```

## 3. 事务快照结构图

```
Snapshot 快照结构
=================

┌─────────────────────────────────────────────────────────────┐
│                      SnapshotData                            │
├─────────────────────────────────────────────────────────────┤
│  xmin:  100    │  最小的仍然活跃的事务ID (含)               │
├────────────────┼────────────────────────────────────────────┤
│  xmax:  110    │  下一个将要分配的事务ID (不含)             │
├────────────────┼────────────────────────────────────────────┤
│  xcnt:  3      │  活跃事务数组的长度                        │
├────────────────┼────────────────────────────────────────────┤
│  xip[]:        │  当前活跃的事务ID列表                      │
│    [0] = 102   │                                            │
│    [1] = 105   │                                            │
│    [2] = 108   │                                            │
├────────────────┼────────────────────────────────────────────┤
│  subxcnt: 0    │  子事务数量                                │
├────────────────┼────────────────────────────────────────────┤
│  subxip[]:     │  活跃子事务ID列表                          │
├────────────────┼────────────────────────────────────────────┤
│  curcid: 0     │  当前命令ID (用于同一事务内的可见性判断)   │
└─────────────────────────────────────────────────────────────┘

时间轴示意：
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        已提交事务       │  活跃事务  │  未来事务
        < xmin           │  xip[]     │  >= xmax
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
XID:  ...98  99  100  101│102 103 104│105 106 107│108 109│110  111...
             ▲           │   ✓    ✓  │   ✓    ✓  │   ✓   │▲
             │           └───────────┴───────────┴───────┘│
             xmin        活跃事务(对当前快照不可见)        xmax

可见性规则：
- XID < xmin            → 已提交，可见
- XID >= xmax           → 未来事务，不可见
- XID in xip[]          → 活跃事务，不可见
- xmin <= XID < xmax && XID not in xip[] → 已提交，可见
```

## 4. 可见性判断流程图

```
HeapTupleSatisfiesMVCC() 可见性判断流程
========================================

开始
  ↓
┌─────────────────────────────────────┐
│ 输入: Tuple, Snapshot, Buffer       │
└─────────────────────────────────────┘
  ↓
┌─────────────────────────────────────┐
│ 步骤1: 检查 t_infomask 提示位       │
│ (快速路径优化)                      │
└─────────────────────────────────────┘
  ↓
  ├─ HEAP_XMIN_INVALID? ──YES→ [返回: 不可见]
  │
  ├─ HEAP_XMIN_COMMITTED? 
  │   ├─ YES → 跳到步骤3
  │   └─ NO → 继续
  ↓
┌─────────────────────────────────────┐
│ 步骤2: 检查 t_xmin (插入事务)       │
└─────────────────────────────────────┘
  ↓
  t_xmin == 当前事务ID?
  ├─ YES → 继续检查 t_cid
  │        ├─ t_cid >= snapshot->curcid? → [不可见]
  │        └─ t_cid < snapshot->curcid?  → 继续
  │
  └─ NO → 检查 t_xmin 在快照中的状态
          ├─ t_xmin >= snapshot->xmax? → [不可见] (未来事务)
          ├─ t_xmin < snapshot->xmin?  → 继续 (已提交)
          └─ t_xmin in snapshot->xip[]? → [不可见] (活跃事务)
                                        → 否则继续
  ↓
  查询 CLOG: t_xmin 是否已提交?
  ├─ ABORTED → 设置 HEAP_XMIN_INVALID → [不可见]
  ├─ IN_PROGRESS → [不可见]
  └─ COMMITTED → 设置 HEAP_XMIN_COMMITTED → 继续
  ↓
┌─────────────────────────────────────┐
│ 步骤3: 检查 t_xmax (删除/更新事务)  │
└─────────────────────────────────────┘
  ↓
  t_xmax == 0 或 HEAP_XMAX_INVALID?
  ├─ YES → [返回: 可见] ✓
  └─ NO → 继续
  ↓
  HEAP_IS_LOCKED?
  ├─ YES → 只是行锁，不影响可见性 → [返回: 可见] ✓
  └─ NO → 继续
  ↓
  t_xmax == 当前事务ID?
  ├─ YES → 同一事务内的删除
  │        ├─ t_cid >= snapshot->curcid? → [可见] ✓
  │        └─ t_cid < snapshot->curcid?  → [不可见]
  │
  └─ NO → 检查 t_xmax 在快照中的状态
          ├─ t_xmax >= snapshot->xmax? → [可见] ✓ (删除事务未来才执行)
          ├─ t_xmax < snapshot->xmin?  → 检查 CLOG
          └─ t_xmax in snapshot->xip[]? → [可见] ✓ (删除事务仍活跃)
                                        → 否则检查 CLOG
  ↓
  查询 CLOG: t_xmax 是否已提交?
  ├─ ABORTED → 设置 HEAP_XMAX_INVALID → [可见] ✓
  ├─ IN_PROGRESS → [可见] ✓
  └─ COMMITTED → 设置 HEAP_XMAX_COMMITTED → [不可见]
  ↓
返回结果

性能优化点：
1. 提示位缓存 (t_infomask): 避免重复查询 CLOG
2. 快照缓存: xip[] 数组在内存中快速查找
3. CLOG 缓存: 最近访问的 CLOG 页面缓存在共享内存
```

## 5. HOT Update 热更新机制

```
HOT (Heap-Only Tuple) Update 优化
==================================

场景：更新不涉及索引列的行

传统更新 vs HOT更新对比
------------------------

【传统更新】需要更新索引
┌─────────────────┐      ┌─────────────────┐
│   索引 B-Tree   │      │   堆表 Page     │
├─────────────────┤      ├─────────────────┤
│ Key=100 → (1,1) │ ───→ │ (1,1) 旧版本    │
│ Key=100 → (2,5) │ ───→ │ (2,5) 新版本    │
└─────────────────┘      └─────────────────┘
问题：索引膨胀、维护开销大


【HOT 更新】不更新索引
┌─────────────────┐      ┌─────────────────────────────────┐
│   索引 B-Tree   │      │   堆表 Page (同一页内)          │
├─────────────────┤      ├─────────────────────────────────┤
│ Key=100 → (1,1) │ ───→ │ (1,1) v1  ──HOT链──→ (1,3) v2  │
│                 │      │  t_xmin=100         t_xmin=105  │
│                 │      │  t_xmax=105         t_xmax=0    │
│                 │      │  HEAP_HOT_UPDATED   HEAP_ONLY   │
└─────────────────┘      └─────────────────────────────────┘
优点：索引不变、性能提升、减少 WAL


HOT 链示例：一行的多个版本
---------------------------

Page N (同一数据页内)
┌────────────────────────────────────────────────────────────┐
│ Line Pointers (行指针数组):                                 │
│   LP[1] → Offset 100   (指向 v1)                           │
│   LP[2] → LP[1]        (重定向指针)                        │
│   LP[3] → Offset 200   (指向 v2)                           │
│   LP[4] → Offset 300   (指向 v3)                           │
├────────────────────────────────────────────────────────────┤
│                                                             │
│  Offset 100: [Tuple v1]                                    │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ t_xmin:  100                                        │   │
│  │ t_xmax:  105                                        │   │
│  │ t_ctid:  (N, 3) ────┐  指向下一个版本                │   │
│  │ t_infomask2: HEAP_HOT_UPDATED                       │   │
│  │ Data: id=1, name='Alice', status='active'           │   │
│  └─────────────────────────────────────────────────────┘   │
│                       │                                     │
│  Offset 200: [Tuple v2] ◄─┘                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ t_xmin:  105                                        │   │
│  │ t_xmax:  108                                        │   │
│  │ t_ctid:  (N, 4) ────┐  指向下一个版本                │   │
│  │ t_infomask2: HEAP_HOT_UPDATED | HEAP_ONLY_TUPLE    │   │
│  │ Data: id=1, name='Alice', status='inactive'         │   │
│  └─────────────────────────────────────────────────────┘   │
│                       │                                     │
│  Offset 300: [Tuple v3] ◄─┘                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ t_xmin:  108                                        │   │
│  │ t_xmax:  0          (当前最新版本)                  │   │
│  │ t_ctid:  (N, 4)     (指向自己)                      │   │
│  │ t_infomask2: HEAP_ONLY_TUPLE                        │   │
│  │ Data: id=1, name='Alice', status='pending'          │   │
│  └─────────────────────────────────────────────────────┘   │
└────────────────────────────────────────────────────────────┘

索引项: index_key → (Page N, LP[1])
      索引只指向第一个版本，通过HOT链找到最新版本


HOT Update 条件检查流程
------------------------

UPDATE table SET non_indexed_col = new_value WHERE ...
  ↓
┌──────────────────────────────────────┐
│ 1. 检查是否满足 HOT 条件              │
└──────────────────────────────────────┘
  ↓
  ├─ 是否更新了索引列? ──YES→ [普通更新]
  │
  ├─ 新旧元组是否在同一页? ──NO→ [普通更新]
  │
  ├─ 页面是否有足够空间? ──NO→ [普通更新]
  │
  └─ 所有条件满足 ──YES→ 执行 HOT 更新
      ↓
    ┌──────────────────────────────────────┐
    │ 2. 执行 HOT 更新                      │
    │  - 在同一页分配新元组                 │
    │  - 设置旧元组 t_xmax 和 t_ctid        │
    │  - 标记 HEAP_HOT_UPDATED              │
    │  - 标记新元组 HEAP_ONLY_TUPLE         │
    │  - 不修改任何索引                     │
    └──────────────────────────────────────┘
      ↓
    ┌──────────────────────────────────────┐
    │ 3. 后续 HOT 链剪枝                    │
    │  (heap_page_prune_opt)                │
    │  - 移除死元组                         │
    │  - 更新行指针重定向                   │
    │  - 不需要 VACUUM                      │
    └──────────────────────────────────────┘
```

## 6. INSERT/UPDATE/DELETE 操作流程

```
【INSERT 操作】
===============

BEGIN
  ↓
┌────────────────────────────────────────┐
│ 1. 获取新的事务ID (GetCurrentTransactionId) │
│    假设 XID = 100                       │
└────────────────────────────────────────┘
  ↓
┌────────────────────────────────────────┐
│ 2. 在堆表中分配新元组                   │
│    - 找到有空闲空间的页面               │
│    - 分配元组存储空间                   │
└────────────────────────────────────────┘
  ↓
┌────────────────────────────────────────┐
│ 3. 设置元组头部                         │
│    t_xmin = 100     (插入事务ID)        │
│    t_xmax = 0       (未删除)            │
│    t_cid = 当前命令ID                   │
│    t_ctid = (当前页, 当前偏移)          │
│    t_infomask = 0   (无提示位)          │
└────────────────────────────────────────┘
  ↓
┌────────────────────────────────────────┐
│ 4. 写入用户数据                         │
│    col1, col2, col3, ...                │
└────────────────────────────────────────┘
  ↓
┌────────────────────────────────────────┐
│ 5. 更新所有索引                         │
│    在每个索引中插入: key → TID          │
└────────────────────────────────────────┘
  ↓
┌────────────────────────────────────────┐
│ 6. 记录 WAL 日志                        │
│    XLOG_HEAP_INSERT                     │
└────────────────────────────────────────┘
  ↓
COMMIT
  ↓
┌────────────────────────────────────────┐
│ 7. 提交事务                             │
│    - 记录 WAL 提交记录                  │
│    - 更新 CLOG: XID 100 → COMMITTED     │
│    - 其他事务现在可以看到这行            │
└────────────────────────────────────────┘


【UPDATE 操作】
===============

BEGIN
  ↓
┌────────────────────────────────────────┐
│ 1. 获取事务ID (假设 XID = 105)          │
└────────────────────────────────────────┘
  ↓
┌────────────────────────────────────────┐
│ 2. 找到要更新的旧元组 (v1)              │
│    - 通过索引或顺序扫描                 │
│    - 检查可见性                         │
└────────────────────────────────────────┘
  ↓
┌────────────────────────────────────────┐
│ 3. 标记旧元组为已删除                   │
│    v1.t_xmax = 105                      │
│    v1.t_infomask |= HEAP_UPDATED        │
└────────────────────────────────────────┘
  ↓
┌────────────────────────────────────────┐
│ 4. 判断是否可以 HOT 更新?               │
│    - 未修改索引列?                      │
│    - 同一页有空间?                      │
└────────────────────────────────────────┘
  ├─ YES: HOT 更新
  │   ┌────────────────────────────────┐
  │   │ 在同一页创建新元组 (v2)        │
  │   │ v1.t_ctid = (same_page, v2)    │
  │   │ v1.t_infomask2 |= HOT_UPDATED  │
  │   │ v2.t_xmin = 105                │
  │   │ v2.t_infomask2 |= HEAP_ONLY    │
  │   │ 不更新索引!                    │
  │   └────────────────────────────────┘
  │
  └─ NO: 普通更新
      ┌────────────────────────────────┐
      │ 在新页或同页创建新元组 (v2)    │
      │ v1.t_ctid = (new_page, v2)     │
      │ v2.t_xmin = 105                │
      │ 更新所有索引: key → v2_TID     │
      └────────────────────────────────┘
  ↓
┌────────────────────────────────────────┐
│ 5. 记录 WAL 日志                        │
│    XLOG_HEAP_UPDATE 或 XLOG_HEAP_HOT_UPDATE │
└────────────────────────────────────────┘
  ↓
COMMIT → 更新 CLOG: XID 105 → COMMITTED


【DELETE 操作】
===============

BEGIN
  ↓
┌────────────────────────────────────────┐
│ 1. 获取事务ID (假设 XID = 110)          │
└────────────────────────────────────────┘
  ↓
┌────────────────────────────────────────┐
│ 2. 找到要删除的元组                     │
│    - 检查可见性                         │
└────────────────────────────────────────┘
  ↓
┌────────────────────────────────────────┐
│ 3. 标记元组为已删除 (逻辑删除)          │
│    tuple.t_xmax = 110                   │
│    tuple.t_infomask |= HEAP_UPDATED     │
└────────────────────────────────────────┘
  ↓
┌────────────────────────────────────────┐
│ 4. 记录 WAL 日志                        │
│    XLOG_HEAP_DELETE                     │
└────────────────────────────────────────┘
  ↓
COMMIT → 更新 CLOG: XID 110 → COMMITTED
  ↓
┌────────────────────────────────────────┐
│ 注意：元组仍然存在于堆表中!             │
│ - 索引仍指向该元组                      │
│ - 仅标记为"已删除"                      │
│ - 需要 VACUUM 物理清除                  │
│ - 对新快照不可见                        │
└────────────────────────────────────────┘
```

## 7. VACUUM 清理流程

```
VACUUM 多版本清理机制
=====================

触发方式：
1. 自动 VACUUM (autovacuum 进程)
2. 手动 VACUUM 命令
3. 页面级 HOT 剪枝 (heap_page_prune_opt)

┌─────────────────────────────────────────────────────────────┐
│                    VACUUM 完整流程                           │
└─────────────────────────────────────────────────────────────┘

第一阶段：扫描堆表，收集死元组
────────────────────────────
  ↓
┌────────────────────────────────────────┐
│ FOR each page in table:                │
│   获取页面的 Exclusive Lock             │
│   ↓                                     │
│   FOR each tuple in page:              │
│     ↓                                   │
│     检查元组是否为"死元组"?             │
│     ┌─────────────────────────────┐    │
│     │ 死元组定义：                │    │
│     │ - t_xmax != 0 (已删除)      │    │
│     │ - t_xmax 已提交             │    │
│     │ - 所有活跃快照都不可见      │    │
│     └─────────────────────────────┘    │
│     ↓                                   │
│     YES → 记录 TID 到 dead_tuples[]    │
│     NO  → 跳过                         │
│   ↓                                     │
│   执行页面级剪枝 (heap_page_prune)      │
│   - 清理 HOT 链的中间节点               │
│   - 更新行指针重定向                    │
└────────────────────────────────────────┘
  ↓
┌────────────────────────────────────────┐
│ 死元组列表 (示例):                      │
│ dead_tuples[] = [                       │
│   (page=1, offset=3),                   │
│   (page=1, offset=7),                   │
│   (page=3, offset=2),                   │
│   (page=5, offset=10),                  │
│   ...                                   │
│ ]                                       │
│ 总计: 10000 个死元组                    │
└────────────────────────────────────────┘

第二阶段：清理索引
──────────────────
  ↓
┌────────────────────────────────────────┐
│ FOR each index on table:               │
│   ↓                                     │
│   调用 ambulkdelete()                   │
│   - 扫描索引 B-Tree                     │
│   - 删除指向 dead_tuples[] 的索引项     │
│   - 标记索引页为"可回收"                │
│   ↓                                     │
│   索引统计信息更新                      │
└────────────────────────────────────────┘

第三阶段：清理堆表
──────────────────
  ↓
┌────────────────────────────────────────┐
│ FOR each page with dead tuples:        │
│   获取页面的 Exclusive Lock             │
│   ↓                                     │
│   移除死元组，压缩页面                  │
│   ┌────────────────────────────────┐   │
│   │ 清理前:                        │   │
│   │ [Tuple1] [DEAD] [Tuple3] [DEAD]│   │
│   │                                │   │
│   │ 清理后:                        │   │
│   │ [Tuple1] [Tuple3] [Free Space] │   │
│   └────────────────────────────────┘   │
│   ↓                                     │
│   更新 FSM (Free Space Map)            │
│   - 记录页面的空闲空间大小              │
└────────────────────────────────────────┘

第四阶段：冻结老事务ID (防止事务ID回卷)
────────────────────────────────────────
  ↓
┌────────────────────────────────────────┐
│ FOR each tuple in table:               │
│   ↓                                     │
│   IF t_xmin < freeze_limit:            │
│     t_xmin = FrozenTransactionId (=2)  │
│     t_infomask |= HEAP_XMIN_FROZEN     │
│   ↓                                     │
│   更新表的 relfrozenxid                 │
└────────────────────────────────────────┘

第五阶段：更新统计信息
──────────────────────
  ↓
┌────────────────────────────────────────┐
│ 更新 pg_class:                          │
│ - reltuples (行数)                      │
│ - relpages (页数)                       │
│ - relallvisible (全可见页数)            │
│ - relfrozenxid (最小未冻结XID)          │
│                                         │
│ 更新 pg_stat 统计视图                   │
└────────────────────────────────────────┘


VACUUM 可见性地图 (Visibility Map)
===================================

每个表一个 VM 文件: table_OID_vm
每页用 2 个bit:
- bit 0: 页面是否全可见 (所有元组对所有事务可见)
- bit 1: 页面是否全冻结 (所有元组已冻结)

┌──────────────────────────────────────────────────────────┐
│ Visibility Map (VM)                                      │
├──────────────────────────────────────────────────────────┤
│ Page 0: [11] 全可见+全冻结 → VACUUM 跳过                 │
│ Page 1: [10] 全可见        → VACUUM 只检查冻结           │
│ Page 2: [00] 有活跃事务    → VACUUM 完整扫描             │
│ Page 3: [11] 全可见+全冻结 → VACUUM 跳过                 │
│ ...                                                       │
└──────────────────────────────────────────────────────────┘

性能优化：
- VACUUM 只扫描 VM 中标记为"非全可见"的页面
- 大幅减少 I/O 和扫描时间
- Index-Only Scan 可以利用 VM 跳过堆表访问
```

## 8. CLOG (提交日志) 结构

```
CLOG (Commit Log / Transaction Status Log)
===========================================

作用：记录每个事务的提交状态
位置：$PGDATA/pg_xact/ 目录

┌─────────────────────────────────────────────────────────────┐
│                    CLOG 文件组织                             │
├─────────────────────────────────────────────────────────────┤
│ 文件: 0000, 0001, 0002, ... (每个文件 256KB)                │
│ 每个 XID 占用 2 bit                                          │
│ 每页 8KB = 8192 字节 = 32768 个事务                          │
│ 每文件 256KB = 32 页 = 1,048,576 个事务                      │
└─────────────────────────────────────────────────────────────┘

事务状态 (2 bit):
┌──────┬─────────────────┬──────────────────────┐
│ 值   │ 状态            │ 说明                 │
├──────┼─────────────────┼──────────────────────┤
│ 00   │ IN_PROGRESS     │ 事务正在执行         │
│ 01   │ COMMITTED       │ 事务已提交           │
│ 10   │ ABORTED         │ 事务已回滚           │
│ 11   │ SUB_COMMITTED   │ 子事务已提交         │
└──────┴─────────────────┴──────────────────────┘

CLOG 页面结构 (8KB):
┌────────────────────────────────────────────────────────────┐
│ CLOG Page (8192 bytes = 32768 transactions)                │
├────────────────────────────────────────────────────────────┤
│ Byte 0:  [XID 0-3]     00 01 10 01 → 进行中,提交,回滚,提交│
│ Byte 1:  [XID 4-7]     01 01 01 00 → 提交,提交,提交,进行中│
│ Byte 2:  [XID 8-11]    ...                                 │
│ ...                                                         │
│ Byte 8191: [XID 32764-32767]                               │
└────────────────────────────────────────────────────────────┘

XID → CLOG 位置映射:
────────────────────
XID = 123456
  ↓
File = XID / (256KB * 4 transactions/byte) = XID / 1048576
     = 123456 / 1048576 = 0  → 文件 "0000"
  ↓
Page = (XID / 32768) % 32 = (123456 / 32768) % 32 = 3
  ↓
Byte = (XID / 4) % 8192 = (123456 / 4) % 8192 = 30864
  ↓
Bit offset = (XID % 4) * 2 = (123456 % 4) * 2 = 0

读取流程:
1. 计算 CLOG 文件和页面号
2. 检查 CLOG 缓冲区 (clog buffer cache)
3. 若未命中，从磁盘读取 CLOG 页面
4. 提取 2 bit 状态
5. 缓存提示位到元组头部 (t_infomask)

性能优化:
- CLOG 页面缓存在共享内存 (默认 128 个页面)
- 元组头部提示位缓存 (避免重复查询 CLOG)
- 异步提交减少 CLOG fsync 开销
```

## 9. 并发场景示例

```
场景1: 脏读防护 (READ COMMITTED 隔离级别)
==========================================

时间轴:
────────────────────────────────────────────────────────────
T1    T2
────────────────────────────────────────────────────────────
BEGIN
XID=100                   BEGIN
                          XID=101
SELECT * FROM t
WHERE id=1
→ 读取 v1
  (t_xmin=50, 已提交)
                          UPDATE t SET val=999
                          WHERE id=1
                          → 创建 v2:
                            t_xmin=101 (未提交)
                            v1.t_xmax=101

SELECT * FROM t
WHERE id=1
→ 检查 v1:
  - t_xmax=101
  - 101 in snapshot->xip[] (活跃)
  - v1 仍然可见 ✓
→ 检查 v2:
  - t_xmin=101
  - 101 in snapshot->xip[] (活跃)
  - v2 不可见 ✗

→ 返回旧值 (防止脏读) ✓

                          COMMIT
                          → CLOG: 101 → COMMITTED

SELECT * FROM t
WHERE id=1
(新快照)
→ v2 现在可见 ✓
→ 返回新值 999

COMMIT
────────────────────────────────────────────────────────────


场景2: 不可重复读 (REPEATABLE READ 隔离级别)
=============================================

时间轴:
────────────────────────────────────────────────────────────
T1 (RR)               T2
────────────────────────────────────────────────────────────
BEGIN
XID=200
Snapshot:
  xmin=200, xmax=201
  xip=[]
                      BEGIN
                      XID=201

SELECT * FROM t
WHERE id=1
→ 读取 val=100
                      UPDATE t SET val=200
                      WHERE id=1
                      
                      COMMIT
                      → CLOG: 201 → COMMITTED

SELECT * FROM t       
WHERE id=1
(使用相同快照!)
→ 检查新版本:
  t_xmin=201
  201 >= snapshot->xmax
  → 不可见 ✗
→ 仍返回 val=100

→ 可重复读保证 ✓

COMMIT
────────────────────────────────────────────────────────────


场景3: 幻读防护 (SERIALIZABLE 隔离级别)
=========================================

使用 Serializable Snapshot Isolation (SSI)
检测读写依赖冲突

时间轴:
────────────────────────────────────────────────────────────
T1 (SERIALIZABLE)     T2 (SERIALIZABLE)
────────────────────────────────────────────────────────────
BEGIN                 BEGIN

SELECT COUNT(*)
FROM t
WHERE val > 100
→ 结果: 5
→ 记录谓词锁:
  "val > 100"
                      INSERT INTO t
                      VALUES (999)
                      (val=999 > 100)
                      
                      → SSI 检测:
                        T1 读了 "val>100"
                        T2 写了 "val=999"
                        → 记录 rw-conflict

                      COMMIT
                      → SSI: T1→T2 依赖

SELECT COUNT(*)
→ 结果: 5 (快照隔离)

UPDATE t SET ...
→ SSI 检测:
  T1→T2→T1 循环依赖!
  
→ ERROR: could not serialize access
  ↓
ROLLBACK (被强制回滚)
────────────────────────────────────────────────────────────
```

## 10. 性能监控查询

```sql
-- 监控表膨胀和死元组
SELECT
  schemaname,
  relname,
  n_live_tup AS live_tuples,
  n_dead_tup AS dead_tuples,
  round(n_dead_tup * 100.0 / NULLIF(n_live_tup + n_dead_tup, 0), 2) AS dead_ratio,
  last_vacuum,
  last_autovacuum
FROM pg_stat_user_tables
ORDER BY n_dead_tup DESC
LIMIT 20;

-- 监控事务ID使用情况 (防止事务ID回卷)
SELECT
  datname,
  age(datfrozenxid) AS xid_age,
  pg_size_pretty(pg_database_size(datname)) AS db_size,
  datfrozenxid
FROM pg_database
ORDER BY xid_age DESC;

-- 监控长事务 (阻碍 VACUUM)
SELECT
  pid,
  usename,
  datname,
  state,
  xact_start,
  now() - xact_start AS duration,
  query
FROM pg_stat_activity
WHERE state IN ('idle in transaction', 'active')
  AND xact_start < now() - interval '1 hour'
ORDER BY xact_start;

-- 检查 CLOG 缓存命中率
SELECT
  'clog' AS buffer_type,
  blks_hit,
  blks_read,
  round(blks_hit * 100.0 / NULLIF(blks_hit + blks_read, 0), 2) AS hit_ratio
FROM pg_stat_slru
WHERE name = 'CommitTs';
```

## 总结

MVCC 架构关键点：
1. **多版本存储**: 每个更新创建新版本，保留旧版本
2. **非阻塞读取**: 读操作不阻塞写，写操作不阻塞读
3. **快照隔离**: 每个事务看到一致的数据快照
4. **可见性判断**: 基于 t_xmin/t_xmax 和快照的快速判断
5. **HOT 优化**: 减少索引更新开销
6. **VACUUM 清理**: 回收死元组空间
7. **CLOG 状态**: 2bit 存储事务提交状态
8. **事务ID 管理**: 防止回卷，定期冻结

性能要点：
- 调优 autovacuum 参数防止膨胀
- 避免长事务阻碍 VACUUM
- 监控死元组比例和事务ID年龄
- 利用 HOT Update 减少索引维护
- 合理设置 fillfactor 为 HOT 留空间

