# MVCC 实现流程分析

> 深入分析 MVCC 的核心流程，包括快照创建、可见性判断、元组更新等关键操作。

---

## 目录

1. [快照创建流程](#一快照创建流程)
2. [可见性判断流程](#二可见性判断流程)
3. [INSERT 操作流程](#三insert-操作流程)
4. [UPDATE 操作流程](#四update-操作流程)
5. [DELETE 操作流程](#五delete-操作流程)
6. [VACUUM 清理流程](#六vacuum-清理流程)

---

## 一、快照创建流程

### 1.1 GetSnapshotData 完整流程

**源码**: `src/backend/utils/time/snapmgr.c:230`

```
Backend 进程开始事务时创建快照:

┌─────────────┐
│ BEGIN;      │
│ SELECT ...  │
└──────┬──────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 1. GetSnapshotData()                 │
│    创建事务快照                      │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 2. 获取 ProcArrayLock (共享锁)       │
│    保护活跃事务数组                  │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 3. 获取下一个 XID                    │
│    xmax = ShmemVariableCache->nextXid│
│    所有 >= xmax 的事务不可见         │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 4. 扫描 ProcArray                    │
│    收集所有活跃事务 ID               │
│                                      │
│    for each backend:                 │
│      xid = proc->xid                 │
│      if (xid < xmax && xid != 0)     │
│        add to xip[]                  │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 5. 确定 xmin                         │
│    xmin = min(xip[])                 │
│    所有 < xmin 的事务已提交          │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 6. 排序 xip 数组                     │
│    qsort(xip, xcnt)                  │
│    二分查找优化                      │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 7. 处理子事务                        │
│    收集活跃子事务到 subxip[]         │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 8. 释放 ProcArrayLock                │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 9. 返回 Snapshot                     │
│    {xmin, xmax, xip[], xcnt}         │
└──────────────────────────────────────┘

示例场景:
─────────────────────────────────────
ProcArray 状态:
  Proc 1: xid = 1000 (活跃)
  Proc 2: xid = 1002 (活跃)
  Proc 3: xid = 0 (空闲)
  Proc 4: xid = 1005 (活跃)
  nextXid = 1009

创建的快照:
  xmin = 1000
  xmax = 1009
  xip = [1000, 1002, 1005]
  xcnt = 3

可见性:
  XID < 1000:  可见 ✓ (已提交)
  1000,1002,1005: 不可见 ✗ (活跃)
  1001,1003,1004: 可见 ✓ (已提交)
  XID >= 1009: 不可见 ✗ (未开始)
```

### 1.2 快照隔离级别

```c
/* 不同隔离级别的快照策略 */

READ COMMITTED:
┌────────────────────────────────────┐
│ 每个 SQL 语句创建新快照            │
│  - SELECT: 创建快照                │
│  - UPDATE: 创建快照                │
│  - 语句间可见性不同                │
└────────────────────────────────────┘

REPEATABLE READ:
┌────────────────────────────────────┐
│ 事务开始时创建一次快照             │
│  - BEGIN: 创建快照                 │
│  - 整个事务使用相同快照            │
│  - 可重复读保证                    │
└────────────────────────────────────┘

SERIALIZABLE:
┌────────────────────────────────────┐
│ 基于 REPEATABLE READ               │
│  + SSI (Serializable Snapshot      │
│     Isolation) 检测                │
│  - 检测读写冲突                    │
│  - 防止序列化异常                  │
└────────────────────────────────────┘
```

---

## 二、可见性判断流程

### 2.1 HeapTupleSatisfiesMVCC

**源码**: `src/backend/access/heap/heapam_visibility.c:1070`

```c
/*
 * HeapTupleSatisfiesMVCC
 * 
 * 判断元组是否对给定快照可见
 * 
 * 输入:
 *  - tuple: 元组头
 *  - snapshot: 快照
 *  - buffer: 缓冲区
 * 
 * 输出:
 *  - true: 可见
 *  - false: 不可见
 */

完整判断流程:

┌─────────────┐
│ 开始判断    │
└──────┬──────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 1. 检查元组是否被删除                │
│    if (t_infomask & HEAP_XMAX_INVALID)│
│      → 未被删除,继续检查 xmin         │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 2. 检查删除事务 xmax (如果已设置)    │
│    if (xmax != 0)                    │
│     ├─ xmax 是否已提交?              │
│     ├─ xmax 对快照可见?              │
│     └─ 如果可见 → 元组已删除         │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 3. 检查插入事务 xmin                 │
│    XidInMVCCSnapshot(xmin, snapshot) │
└──────┬───────────────────────────────┘
       │
       ├─ Case 1: xmin < snapshot->xmin
       │   → 所有旧事务已提交
       │   → 检查 xmin 是否已提交
       │        ▼
       │   ┌────────────────────────────┐
       │   │ 检查提示位或 CLOG          │
       │   │  if (HEAP_XMIN_COMMITTED)  │
       │   │    return true ✓           │
       │   └────────────────────────────┘
       │
       ├─ Case 2: xmin 在 [xmin, xmax) 且在 xip[]
       │   → 创建快照时正在运行
       │   → return false ✗
       │
       ├─ Case 3: xmin 在 [xmin, xmax) 但不在 xip[]
       │   → 快照创建前已提交
       │   → 检查 CLOG
       │        ▼
       │   ┌────────────────────────────┐
       │   │ if (TransactionIdDidCommit)│
       │   │    return true ✓           │
       │   └────────────────────────────┘
       │
       └─ Case 4: xmin >= snapshot->xmax
           → 快照后开始的事务
           → return false ✗

决策树:
                    开始
                     │
                     ▼
            ┌────────────────┐
            │ xmax != 0 ?    │
            └────┬───────┬───┘
                 │ Y     │ N
                 ▼       ▼
          ┌──────────┐  继续
          │检查 xmax │
          │可见性    │
          └─────┬────┘
                │ 已删除
                ▼
           return FALSE
                │ 未删除
                ▼
         ┌──────────────┐
         │ 检查 xmin    │
         └──────┬───────┘
                │
      ┌─────────┼─────────┐
      │         │         │
      ▼         ▼         ▼
   < xmin   in xip?   >= xmax
      │         │         │
   ┌──┴──┐  ┌──┴──┐  ┌──┴──┐
   │检查 │  │FALSE│  │FALSE│
   │CLOG │  └─────┘  └─────┘
   └──┬──┘
      │
   return TRUE/FALSE
```

### 2.2 可见性判断示例

```
场景设置:
─────────────────────────────────────
快照: {xmin: 1000, xmax: 1010, xip: [1002, 1005]}

元组版本:
┌─────────────────────────────────────┐
│ Tuple A                             │
│  t_xmin = 999                       │
│  t_xmax = 0                         │
│  t_infomask = HEAP_XMIN_COMMITTED   │
└─────────────────────────────────────┘

判断过程:
1. xmax = 0 → 未被删除 ✓
2. xmin = 999 < snapshot->xmin (1000)
3. 检查提示位: HEAP_XMIN_COMMITTED ✓
4. 结果: 可见 ✓

┌─────────────────────────────────────┐
│ Tuple B                             │
│  t_xmin = 1002                      │
│  t_xmax = 0                         │
└─────────────────────────────────────┘

判断过程:
1. xmax = 0 → 未被删除 ✓
2. xmin = 1002 在 [1000, 1010)
3. 1002 在 xip[] 中 → 创建快照时活跃
4. 结果: 不可见 ✗

┌─────────────────────────────────────┐
│ Tuple C                             │
│  t_xmin = 1001                      │
│  t_xmax = 0                         │
└─────────────────────────────────────┘

判断过程:
1. xmax = 0 → 未被删除 ✓
2. xmin = 1001 在 [1000, 1010)
3. 1001 不在 xip[] → 已提交
4. 检查 CLOG: COMMITTED ✓
5. 结果: 可见 ✓

┌─────────────────────────────────────┐
│ Tuple D                             │
│  t_xmin = 995                       │
│  t_xmax = 1002                      │
│  t_infomask = HEAP_XMAX_COMMITTED   │
└─────────────────────────────────────┘

判断过程:
1. xmax = 1002 != 0
2. 1002 在 xip[] → 删除事务还在运行
3. 结果: 可见 ✓ (删除未提交)

如果快照是 {xmin: 1003, xmax: 1010, xip: [1005]}:
1. xmax = 1002 < 1003
2. xmax 已提交 (检查 CLOG 或提示位)
3. 结果: 不可见 ✗ (已被删除)
```

---

## 三、INSERT 操作流程

### 3.1 heap_insert 完整流程

**源码**: `src/backend/access/heap/heapam.c:2000`

```
INSERT INTO users VALUES (100, 'Alice', 25);

┌─────────────┐
│ Executor    │
│ ExecInsert()│
└──────┬──────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 1. heap_insert()                     │
│    插入新元组                        │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 2. 获取当前事务 ID                   │
│    xid = GetCurrentTransactionId()   │
│    例如: xid = 1005                  │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 3. 构造元组头                        │
│    t_xmin = 1005                     │
│    t_xmax = 0                        │
│    t_cid = current_command_id        │
│    t_ctid = (0, 0) // 稍后设置       │
│    t_infomask = 0                    │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 4. 查找可插入页面                    │
│    RelationGetBufferForTuple()       │
│     ├─ 使用 FSM 查找有空间的页      │
│     └─ 如果没有,扩展新页面           │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 5. 生成 WAL 记录                     │
│    XLogBeginInsert()                 │
│    XLogRegisterData(tuple)           │
│    lsn = XLogInsert(RM_HEAP_INSERT)  │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 6. 在页面中插入元组                  │
│    PageAddItem()                     │
│     ├─ 分配 Line Pointer            │
│     ├─ 拷贝元组数据                 │
│     └─ 更新 t_ctid                  │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 7. 设置页面 LSN                      │
│    PageSetLSN(page, lsn)             │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 8. 标记 Buffer 脏                    │
│    MarkBufferDirty(buffer)           │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 9. 释放 Buffer                       │
│    UnlockReleaseBuffer(buffer)       │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 10. 更新索引 (如果有)                │
│     index_insert()                   │
└──────────────────────────────────────┘

插入后元组状态:
┌─────────────────────────────────────┐
│ TID: (5, 12)                        │
│ t_xmin: 1005                        │
│ t_xmax: 0                           │
│ t_cid: 7                            │
│ t_ctid: (5, 12) // 指向自己         │
│ t_infomask: 0 // 无提示位           │
│ data: {id:100, name:'Alice', age:25}│
└─────────────────────────────────────┘

可见性:
─────────────────────────────────────
对于事务 1005 (插入者):
  - 立即可见 ✓

对于其他已开始事务:
  - 不可见 ✗ (xmin=1005 > 其快照的 xmax)

对于事务 1005 提交后的新事务:
  - 可见 ✓ (xmin=1005 < 新快照的 xmin)
```

---

## 四、UPDATE 操作流程

### 4.1 heap_update 完整流程

**源码**: `src/backend/access/heap/heapam.c:2800`

```
UPDATE users SET name = 'Bob' WHERE id = 100;

┌─────────────┐
│ Executor    │
│ ExecUpdate()│
└──────┬──────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 1. 定位旧元组                        │
│    heap_fetch() / index_scan         │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 2. 检查旧元组是否可更新              │
│    HeapTupleSatisfiesUpdate()        │
│     - 检查是否被其他事务锁定         │
│     - 检查是否已被删除               │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 3. heap_update()                     │
│    xid = GetCurrentTransactionId()   │
│    例如: xid = 1008                  │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 4. 标记旧元组为已删除                │
│    old_tuple->t_xmax = 1008          │
│    old_tuple->t_infomask |=          │
│        HEAP_XMAX_EXCL_LOCK           │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 5. 检查是否可以 HOT Update          │
│    if (可以 HOT)                     │
│      → 在同一页面内更新             │
│    else                              │
│      → 创建新页面的新元组           │
└──────┬───────────────────────────────┘
       │
       ▼ (假设非 HOT)
┌──────────────────────────────────────┐
│ 6. 创建新元组                        │
│    new_tuple->t_xmin = 1008          │
│    new_tuple->t_xmax = 0             │
│    new_tuple->t_cid = current_cid    │
│    new_tuple->data = 新数据          │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 7. 更新旧元组的 t_ctid               │
│    old_tuple->t_ctid = new_tuple_tid │
│    建立版本链                        │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 8. 生成 WAL 记录                     │
│    XLogInsert(RM_HEAP_UPDATE)        │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 9. 插入新元组到页面                  │
│    PageAddItem()                     │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 10. 更新索引                         │
│     index_insert() / index_delete()  │
└──────────────────────────────────────┘

UPDATE 后状态:
─────────────────────────────────────
旧元组 (5, 12):
┌─────────────────────────────────────┐
│ t_xmin: 1005                        │
│ t_xmax: 1008 ← 被标记删除           │
│ t_ctid: (7, 5) ← 指向新版本         │
│ data: {name: 'Alice'}               │
└─────────────────────────────────────┘

新元组 (7, 5):
┌─────────────────────────────────────┐
│ t_xmin: 1008 ← 新事务创建           │
│ t_xmax: 0                           │
│ t_ctid: (7, 5) ← 指向自己           │
│ data: {name: 'Bob'}                 │
└─────────────────────────────────────┘

可见性 (事务 1008 提交前):
─────────────────────────────────────
快照 {xmin:1000, xmax:1008, xip:[1002, 1005]}:
  - 看到旧版本 'Alice' ✓

快照 {xmin:1009, xmax:1015, xip:[...]}:
  - 看到新版本 'Bob' ✓
```

### 4.2 HOT (Heap Only Tuple) Update

```
HOT Update 条件:
─────────────────────────────────────
1. 新元组在同一页面
2. 未更新索引键列
3. 页面有足够空间

HOT Update 流程:
┌─────────────────────────────────────┐
│ 旧元组 (5, 3)                       │
│  t_xmin: 1000                       │
│  t_xmax: 1005                       │
│  t_ctid: (5, 7) ← 同页             │
│  t_infomask: HEAP_HOT_UPDATED      │
└──────────┬──────────────────────────┘
           │ (同一页内)
           ▼
┌─────────────────────────────────────┐
│ 新元组 (5, 7)                       │
│  t_xmin: 1005                       │
│  t_xmax: 0                          │
│  t_ctid: (5, 7)                     │
│  t_infomask: HEAP_ONLY_TUPLE       │
└─────────────────────────────────────┘

HOT 优势:
─────────────────────────────────────
✓ 无需更新索引 (大幅提升性能)
✓ 减少表膨胀
✓ 减少 VACUUM 负担
```

---

## 五、DELETE 操作流程

### 5.1 heap_delete 流程

**源码**: `src/backend/access/heap/heapam.c:3200`

```
DELETE FROM users WHERE id = 100;

┌──────────────────────────────────────┐
│ 1. 定位要删除的元组                  │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 2. heap_delete()                     │
│    xid = GetCurrentTransactionId()   │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 3. 设置元组的 t_xmax                 │
│    tuple->t_xmax = xid               │
│    标记为"被删除"                    │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 4. 生成 WAL 记录                     │
│    XLogInsert(RM_HEAP_DELETE)        │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 5. 标记 Buffer 脏                    │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 6. 更新索引 (标记删除)               │
│    index_delete()                    │
└──────────────────────────────────────┘

DELETE 后状态:
┌─────────────────────────────────────┐
│ 元组 (5, 12)                        │
│ t_xmin: 1005                        │
│ t_xmax: 1010 ← 删除事务 ID          │
│ t_infomask: (无 HEAP_XMAX_COMMITTED)│
│ data: {id:100, name:'Alice', age:25}│
└─────────────────────────────────────┘

注意: 数据并未物理删除!
  - 仅设置 t_xmax
  - 后续由 VACUUM 清理
  - 在此之前仍占用空间

可见性 (事务 1010 提交前):
─────────────────────────────────────
快照 {xmin:1000, xmax:1010, xip:[1008]}:
  - 可见 ✓ (xmax 还在 xip 中)

快照 {xmin:1011, xmax:1015, xip:[...]}:
  - 不可见 ✗ (xmax 已提交)
```

---

## 六、VACUUM 清理流程

### 6.1 heap_page_prune 流程

**源码**: `src/backend/access/heap/pruneheap.c:300`

```
VACUUM 清理死元组:

┌─────────────┐
│ VACUUM      │
│ users;      │
└──────┬──────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 1. 扫描表的每一页                    │
│    for each page                     │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 2. heap_page_prune()                 │
│    清理页面内的死元组                │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 3. 对每个元组判断:                   │
│    HeapTupleSatisfiesVacuum()        │
│     ├─ DEAD: 可以删除               │
│     ├─ RECENTLY_DEAD: 暂不能删      │
│     ├─ LIVE: 保留                   │
│     └─ INSERT_IN_PROGRESS: 等待     │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 4. 清理 DEAD 元组                    │
│    PageRepairFragmentation()         │
│     ├─ 标记 Line Pointer 为 DEAD    │
│     ├─ 压缩页面空间                 │
│     └─ 更新 FSM                     │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 5. 清理索引死条目                    │
│    index_vacuum_cleanup()            │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 6. 更新统计信息                      │
│    pg_class.reltuples                │
│    pg_class.relpages                 │
└──────┬───────────────────────────────┘
       │
       ▼
┌──────────────────────────────────────┐
│ 7. 冻结旧事务 ID                     │
│    heap_freeze_tuple()               │
│    t_xmin = FrozenTransactionId (2)  │
└──────────────────────────────────────┘

VACUUM 效果:
─────────────────────────────────────
清理前:
┌────────────────────────────────┐
│ Page 5                         │
│ ├─ Tuple 1 (DEAD)              │
│ ├─ Tuple 2 (LIVE)              │
│ ├─ Tuple 3 (DEAD)              │
│ ├─ Tuple 4 (LIVE)              │
│ └─ Free: 1KB                   │
└────────────────────────────────┘

清理后:
┌────────────────────────────────┐
│ Page 5                         │
│ ├─ Tuple 2 (LIVE)              │
│ ├─ Tuple 4 (LIVE)              │
│ └─ Free: 5KB ← 回收空间        │
└────────────────────────────────┘
```

---

## 总结

### MVCC 实现的关键流程

1. **快照创建**: 捕获活跃事务,定义可见性
2. **可见性判断**: 基于 xmin/xmax 和快照
3. **INSERT**: 设置 t_xmin,立即对当前事务可见
4. **UPDATE**: 创建新版本,保留旧版本
5. **DELETE**: 标记 t_xmax,延迟物理删除
6. **VACUUM**: 清理死元组,回收空间

### 性能要点

- ✅ 快照创建快速 (ProcArrayLock 持有时间短)
- ✅ 可见性判断优化 (提示位避免 CLOG 查询)
- ✅ HOT Update 减少索引维护
- ✅ 延迟删除平摊开销

---

**文档版本**: 1.0
**相关源码**: PostgreSQL 17.5
**创建日期**: 2025-01-16

**下一篇**: [04_key_algorithms.md](04_key_algorithms.md) - MVCC 关键算法详解


