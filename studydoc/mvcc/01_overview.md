# MVCC (Multi-Version Concurrency Control) 模块概述

> MVCC 是 PostgreSQL 实现高并发读写的核心技术，通过多版本数据避免读写阻塞，实现真正的非锁定并发。

---

## 目录

1. [MVCC 核心概念](#一mvcc-核心概念)
2. [为什么需要 MVCC](#二为什么需要-mvcc)
3. [MVCC 工作原理](#三mvcc-工作原理)
4. [版本可见性规则](#四版本可见性规则)
5. [MVCC 的优势](#五mvcc-的优势)
6. [与其它并发控制方式对比](#六与其它并发控制方式对比)

---

## 一、MVCC 核心概念

### 1.1 什么是 MVCC？

MVCC (Multi-Version Concurrency Control) 是一种并发控制机制，允许多个事务同时访问同一份数据而不相互阻塞。

```
传统锁定方式 vs MVCC 方式:

传统方式 (悲观锁):
┌─────────────────────────────────────────────────────────────┐
│ 事务 A 读取: SELECT * FROM users WHERE id = 1              │
│ ────────────────────────────────────────────────┐          │
│ ┌──────────────┐        ┌──────────────┐       │          │
│ │ Readers      │        │ Writers      │       │          │
│ │ 互相阻塞       │  ←─────│ 互相阻塞       │       │          │
│ 步骤:                                    │          │
│ 读者 1:                                │          │
│ 1. 加读锁                              │          │
│ 2. 读取数据                            │          │
│ 3. 释放锁                              │          │
│                                                │          │
│ 写者 2:                                │          │
│ 1. 等待读锁释放                         │          │
│ 2. 加写锁                              │          │
│ 3. 修改数据                            │          │
│ 4. 释放锁                              │          │
│ └──────────────┘        └──────────────┘       │          │
│ 结果:                                      │          │
│ - 读者和写者互相等待                         │          │
│ - 并发度低                                 │          │
│ - 可能死锁                                 │          │
└─────────────────────────────────────────────────────────────┘

MVCC 方式 (乐观并发):
┌─────────────────────────────────────────────────────────────┐
│ 事务 A 读取: SELECT * FROM users WHERE id = 1              │
│ ────────────────────────────────────────┐                  │
│ ┌────────────────────────────────────────┐              │ │
│ │            MVCC 架构                   │              │ │
│ │                                      │              │ │
│ │ Time Line (时间轴)                    │              │ │
│ │ T1 ──┐                                │              │ │
│ │      │  原始数据: {id:1, name:'Alice'} │              │ │
│ │      └─────────────────────────────────┘              │ │
│ │ T2 ──┬───────┐                        │              │ │
│ │      │  事务A │: 读取原始数据           │              │ │
│ │      │  快照:  │ xmin=5, xmax=6         │              │ │
│ │      └───────┘                        │              │ │
│ │ T3 ──┬─────────────┐                  │              │ │
│ │      │   事务B       │: 修改数据        │              │ │
│ │      │   └─ 新版本   │: {id:1, name:'Bob'}│              │ │
│ │      │   xid=7       │                  │              │ │
│ │      └─────────────┘                  │              │ │
│ │ T4 ──┬───────┐                        │              │ │
│ │      │  事务A │: 仍读取原始版本         │              │ │
│ │      │        │(读取时已创建的快照)     │              │ │
│ │      └───────┘                        │              │ │
│ │                                      │              │ │
│ │ 数据版本:                            │              │ │
│ │ ┌─────────────────────────────────┐  │              │ │
│ │ │ Page 第1页 (Block 0)            │  │              │ │
│ │ │                                 │  │              │ │
│ │ │ T1: ┌───────────────────────┐   │  │              │ │
│ │ │     │ LinePtr 1 → Tuple A    │   │  │              │ │
│ │ │     │ t_xmin = 3             │   │  │              │ │
│ │ │     │ t_xmax = 0             │   │              │ │
│ │ │     │ data: {name:'Alice'}   │   │  │              │ │
│ │ │     └───────────────────────┘   │  │              │ │
│ │ │                                 │  │              │ │
│ │ │ T3: ┌───────────────────────┐   │  │              │ │
│ │ │     │ LinePtr 2 → Tuple B    │   │  │              │ │
│ │ │     │ t_xmin = 7             │   │              │ │
│ │ │     │ t_xmax = 0             │   │              │ │
│ │ │     │ data: {name:'Bob'}     │   │              │ │
│ │ │     │        ↑               │   │              │ │
│ │ │     │        │ t_ctid = (0,2) │   │              │ │
│ │ │     └───────────────────────┘   │  │              │ │
│ │ │                                 │  │              │ │
│ │ │ 可见性判断:                        │  │              │ │
│ │ │ - 事务A看: Tuple A (xmin=3 < xmin=5?)  → 不可见       │  │              │ │
│ │ │ - 事务A看: Tuple B (xmin=7 > xmax=6?)  → 不可见       │  │              │ │
│ │ │ - 更复杂的情况需要检查事务状态         │  │              │ │
│ │ └─────────────────────────────────────────┘              │ │
│ │                                      │              │ │
│ └────────────────────────────────────────┘              │ │
│                                                       │ │
│ 结果:                                                  │ │
│ - 读者和写者不阻塞                                      │ │
│ - 每个事务看到一致的数据快照                            │ │
│ - 高并发度                                             │ │
│ └─────────────────────────────────────────────────────┘
```

### 1.2 MVCC 核心要素

| 要素 | 作用 | 实现方式 |
|------|------|----------|
| **事务 ID (XID)** | 标记事务的全局唯一标识 | 32位递增数字 |
| **快照 (Snapshot)** | 记录事务执行时的数据版本状态 |xmin, xmax, 活跃事务列表|
| **元组版本** | 每个元组记录创建和删除事务ID | t_xmin, t_xmax |
| **可见性规则** | 决定元组对事务是否可见 | 一套复杂的规则 |
| **事务状态缓存** | 缓存事务提交状态，提高性能 | CLOG + Subtrans |

---

## 二、为什么需要 MVCC？

### 2.1 传统数据库的并发问题

```
场景: 多用户同时修改同一份数据

问题场景分析:

┌─────────────────────┐  ┌─────────────────────┐  ┌─────────────────────┐
│    用户 A (银行柜员)   │  │    用户 B (ATM)      │  │    用户 C (网银)     │
│                     │  │                     │  │                     │
│ 账户余额: $1000      │  │ 账户余额: $1000      │  │ 账户余额: $1000      │
└─────────┬───────────┘  └─────────┬───────────┘  └─────────┬───────────┘
          │                       │                       │
          │ T1: 开始事务           │ T2: 开始事务           │ T3: 开始事务
          ▼                       ▼                       ▼
┌─────────────────────┐  ┌─────────────────────┐  ┌─────────────────────┐
│ 读取余额             │  │ 读取余额             │  │ 读取余额             │
│ SELECT balance FROM  │  │ SELECT balance FROM  │  │ SELECT balance FROM  │
│ accounts WHERE id=1  │  │ accounts WHERE id=1  │  │ accounts WHERE id=1  │
│ → $1000             │  │ → $1000             │  │ → $1000             │
└─────────┬───────────┘  └─────────┬───────────┘  └─────────┬───────────┘
          │                       │                       │
          │ T4: 计算处理          │ T5: 计算处理          │ T6: 计算处理
          │    $1000 - $100      │    $1000 - $200      │    $1000 - $50      │
          │    = $900           │    = $800           │    = $950           │
          ▼                       ▼                       ▼
┌─────────────────────┐  ┌─────────────────────┐  ┌─────────────────────┐
│ 更新余额             │  │ 更新余额             │  │ 更新余额             │
│ UPDATE accounts      │  │ UPDATE accounts      │  │ UPDATE accounts      │
│ SET balance = $900   │  │ SET balance = $800   │  │ SET balance = $950   │
│ WHERE id = 1         │  │ WHERE id = 1         │  │ WHERE id = 1         │
│ ← T7: 等待...        │  │ ← T8: 等待...        │  │ ← T9: 等待...        │
└─────────┬───────────┘  └─────────┬───────────┘  └─────────┬───────────┘
          │                       │                       │
          ▼                       ▼                       ▼
结果 (传统锁定):
┌─────────────────────────────────────────────────────────────────┐
│ 执行序列 (假设):                                               │
│ 1. 用户A获锁，更新为$900                                       │
│ 2. 用户B获锁，更新为$800 (覆盖了A的修改)                        │
│ 3. 用户C获锁，更新为$950                                        │
│                                                               │
│ 最终结果: 余额$950 (不一致！应该是$750)                        │
│ 问题:                                                         │
│ - 丢失更新 (Lost Update)                                       │
│ - 不可重复读                                                   │
│ - 脏读                                                         │
│ - 死锁风险                                                     │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 MVCC 如何解决这些问题

```
MVCC 解决方案:

时间线分析:
T1    T2          T3          T4          T5          T6          T7          T8          T9
│     │           │           │           │           │           │           │           │
│     │           │           │           │           │           │           │           │
└─txnA:读取─────────────────┘           └─txnA:提交────────────────────┘
        └─txnB:读取─────────────┘           └─txnB:提交────────────────┘
                └─txnC:读取─────────┘           └─txnC:提交────────────┘

数据版本演化:
┌─────────────────────────────────────────────────────────────────┐
│                    accounts 表 (id=1)                          │
│                                                               │
│ T1-T2: 初始状态                                                │
│ ┌───────────────────────────────────────────────────────────┐ │
│ │ Tuple_v0                                                  │ │
│ │ t_xmin = 100 (创建事务)                                  │ │
│ │ t_xmax = 0 (未被删除)                                     │ │
│ │ balance = $1000                                           │ │
│ └───────────────────────────────────────────────────────────┘ │
│                                                               │
│ T4: 用户A 修改版本                                             │
│ ┌───────────────────────────────────────────────────────────┐ │
│ │ Tuple_v0 (旧版本)                                          │ │
│ │ t_xmin = 100                                              │ │
│ │ t_xmax = 101 (被事务101删除)                               │ │
│ │ balance = $1000                                           │ │
│ └───────────────────────────────────────────────────────────┘ │
│ ┌───────────────────────────────────────────────────────────┐ │
│ │ Tuple_v1 (用户A的版本)                                     │ │
│ │ t_xmin = 101 (创建事务)                                  │ │
│ │ t_xmax = 0                                                │ │
│ │ balance = $900                                            │ │
│ └───────────────────────────────────────────────────────────┘ │
│                                                               │
│ T5: 用户B 修改版本                                             │
│ ┌───────────────────────────────────────────────────────────┐ │
│ │ Tuple_v0                                                  │ │
│ │ t_xmin = 100, t_xmax = 101                                │ │
│ │ balance = $1000                                           │ │
│ └───────────────────────────────────────────────────────────┘ │
│ ┌───────────────────────────────────────────────────────────┐ │
│ │ Tuple_v1                                                  │ │
│ │ t_xmin = 101, t_xmax = 102 (被事务102删除)                │ │
│ │ balance = $900                                            │ │
│ └───────────────────────────────────────────────────────────┘ │
│ ┌───────────────────────────────────────────────────────────┐ │
│ │ Tuple_v2 (用户B的版本)                                     │ │
│ │ t_xmin = 102 (创建事务)                                  │ │
│ │ t_xmax = 0                                                │ │
│ │ balance = $800                                            │ │
│ └───────────────────────────────────────────────────────────┘ │
│                                                               │
│ T6: 用户C 修改版本                                             │
│ (继续添加新版本...)                                           │
│                                                               │
│ 各事务的可见性:                                               │
│ - 事务A(101): 看到 Tuple_v0 → 修改 → Tuple_v1                 │
│ - 事务B(102): 看到 Tuple_v0 → 修改 → Tuple_v2                 │
│ - 事务C(103): 看到 Tuple_v0 → 修改 → Tuple_v3                 │
│                                                               │
│ 最终结果: 所有修改都能保留，没有丢失                            │
└─────────────────────────────────────────────────────────────────┘
```

---

## 三、MVCC 工作原理

### 3.1 MVCC 核心机制

```
MVCC 工作流程全景图:

┌─────────────────────────────────────────────────────────────────┐
│                        MVCC 核心引擎                             │
└─────────────────────────────────────────────────────────────────┘
                              │
         ┌────────────────────┴────────────────────┐
         │                                         │
         ▼                                         ▼
┌──────────────────────┐              ┌──────────────────────┐
│   事务管理器          │              │   版本存储引擎        │
│ Transaction Manager    │              │  Version Store       │
└──────────┬───────────┘              └──────────┬───────────┘
           │                                    │
    ┌──────┴──────┐                    ┌────────┴────────┐
    ▼             ▼                    ▼                 ▼
┌──────────┐ ┌──────────┐         ┌──────────┐     ┌──────────┐
│事务ID分配 │ │快照管理   │         │元组版本化 │     │可见性检查 │
│XID       │ │Snapshot  │         │Tuple     │     │Visibility│
└──────────┘ └──────────┘         └──────────┘     └──────────┘
    │             │                    │                 │
    ▼             ▼                    ▼                 ▼
┌─────────────────────────────────────────────────────────────┐
│    核心数据流:                                             │
│                                                           │
│ 1. 事务开始:                                              │
│    ├── 分配 XID (Transaction ID)                          │
│    └── 创建快照 (xmin, xmax, xip[])                       │
│                                                           │
│ 2. 读取数据:                                              │
│    ├── 扫描元组版本                                        │
│    ├── 应用可见性规则                                      │
│    └── 返回可见元组                                        │
│                                                           │
│ 3. 修改数据:                                              │
│    ├── 创建新版本元组                                      │
│    ├── 设置 t_xmin = 当前XID                               │
│    ├── 标记旧版本 t_xmax = 当前XID                         │
│    └── 插入新元组                                          │
│                                                           │
│ 4. 事务提交:                                              │
│    ├── 记录提交状态到 CLOG                                 │
│    ├── 清理相关资源                                        │
│    └── 发送提交通知                                        │
│                                                           │
│ 5. 事务回滚:                                              │
│    ├── 记录回滚状态到 CLOG                                 │
│    ├── 清理创建的新版本                                    │
│    └── 恢复旧版本状态                                      │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 事务快照详解

```
Snapshot 结构 (数据结构):

┌─────────────────────────────────────────────────────────────┐
│                  Transaction Snapshot                        │
│                (src/backend/utils/time/snapshot.h)          │
│                                                             │
│ typedef struct SnapshotData                                  │
│ {                                                           │
│     /* 快照类型 */                                           │
│     SnapshotType snapshot_type;                              │
│                                                             │
│     /* 快照级别 */                                           │
│     int32       level;                                      │
│                                                             │
│     /* LSN 定位点 */                                         │
│     XLogRecPtr  lsns[PG_NUM_SNAPSHOT_LSELEMENTS];           │
│                                                             │
│     /* 时间戳 */                                             │
│     TimestampTz whenTaken;                                  │
│                                                             │
│     /* 可见性范围：xmin 和 xmax */                           │
│     TransactionId xmin;    // 小于此XID的事务不可见         │
│     TransactionId xmax;    // 大于此XID的事务不可见         │
│                                                             │
│     /* 活跃事务列表 */                                       │
│     TransactionId *xip;    // 大于xmin且小于xmax的活跃事务    │
│     uint32      xcnt;    // 活跃事务数量                    │
│                                                             │
│     /* 子事务信息 */                                         │
│     TransactionId *subxip; // 活跃子事务列表                │
│     int32       subxcnt;  // 子事务数量                     │
│                                                             │
│     /* 命令计数 */                                           │
│     CommandId   curcid;   // 当前命令ID                     │
│                                                             │
│ } SnapshotData;                                             │
└─────────────────────────────────────────────────────────────┘

Snapshot 创建过程:

Transaction A: XID = 500 (开始)
┌─────────────────────────────────────────────────────────────┐
│ 步骤 1: 获取全局事务计数器                                   │
│ GetNewTransactionId() → 返回 500                             │
│                                                             │
│ 步骤 2: 创建快照                                            │
│ GetSnapshotData():                                         │
│ └─ 获取全局 xmin                                            │
│     ├─ 查看所有活跃进程                                     │
│     ├─ 找到最小的XID: xmin = 495                           │
│     └─ 含义:XID<495 的事务都已提交                          │
│                                                             │
│ └─ 获取全局 xmax                                            │
│     ├─ 读取全局事务计数器                                   │
│     └─ xmax = 501 (下一个可用XID)                          │
│     └─ 含义:XID≥501 的事务都未开始                          │
│                                                             │
│ └─ 获取活跃事务列表                                         │
│     ├─ 扫描所有进程                                        │
│     ├─ 记录活跃XID: [498, 501, 502]                       │
│     └─ 含义:这些事务正在进行，不可见                         │
│                                                             │
│                            ↓                                │
│                                                            ↓ │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ Transaction*(500) 快照:                                 │ │
│ │ xmin = 495 (小于495的都可见)                            │ │
│ │ xmax = 501 (大于等于501的都不可见)                      │ │
│ │ xip = {498, 501, 502} (这些活跃事务不可见)              │ │
│ │ curcid = 0 (第一条命令)                                 │ │
│ └─────────────────────────────────────────────────────────┘ │
│                                                             │
│ 快照含义:                                                   │
│ - XID < 495: 已提交 ✓                                       │
│ - XID = 498: 考虑 (但事务活跃，不可见) ✗                    │
│ - XID = 500: 自己 ✓ (特殊处理)                              │
│ - XID ≥ 501: 未开始 ✗                                       │
└─────────────────────────────────────────────────────────────┘
```

### 3.3 元组版本化机制

```
Heap Tuple 版本化过程:

原始数据:
┌─────────────────────────────────────────────────────────────┐
│ Page Header (8KB)                                          │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ LinePtr[0] → Offset: 8000, Length: 50                  │ │
│ │ LinePtr[1] → Offset: 7950, Length: 45                  │ │
│ └─────────────────────────────────────────────────────────┘ │
│                                                             │
│ ... (空闲空间) ...                                            │
│                                                             │
│ Offset 8000:                                                │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ HeapTupleHeader (23 bytes)                               │ │
│ │  t_xmin = 100  (创建事务)                                │ │
│ │  t_xmax = 0    (未被删除)                                │ │
│ │  t_cid = 0      (命令ID)                                 │ │
│ │  t_ctid = (0,0) (当前位置)                              │ │
│ │  t_infomask = HEAP_HASVARWIDTH                          │ │
│ │                                                         │ │
│ │ User Data:                                               │ │
│ │  name = 'Alice', age = 25                                 │ │
│ │  total: 27 bytes → LinePtr.length = 50                 │ │
│ └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘

UPDATE 操作 (事务 XID = 200)后的变化:

步骤 1: 标记旧元组删除
┌─────────────────────────────────────────────────────────────┐
│ Offset 8000: (被标记删除的元组)                              │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ HeapTupleHeader                                         │ │
│ │  t_xmin = 100  (原始创建事务)                           │ │
│ │  t_xmax = 200  (被事务200删除)                          │ │
│ │  t_cid = 0                                             │ │
│ │  t_ctid = (0,1) (新的元组位置) ← 重定向                   │ │
│ │  t_infomask = HEAP_HASVARWIDTH | HEAP_UPDATED           │ │
│ │                                                         │ │
│ │ User Data:                                               │ │
│ │  name = 'Alice', age = 25                                 │ │
│ └─────────────────────────────────────────────────────────┘ │
│                                                             │
│ 变化说明:                                                    │
│ - t_xmax 从 0 变为 200 (标记被事务200删除)                   │
│ - t_ctid 从 (0,0) 变为 (0,1) (指向新版本)                   │
│ - HEAP_UPDATED 标志位セット                                 │
└─────────────────────────────────────────────────────────────┘

步骤 2: 创建新元组
┌─────────────────────────────────────────────────────────────┐
│ Page Header:                                                │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ LinePtr[0] → Offset: 8000, Length: 50 (旧版本)         │ │
│ │ LinePtr[1] → Offset: 7900, Length: 50 (新版本) ← 新增   │ │
│ └─────────────────────────────────────────────────────────┘ │
│ pd_lower = 24 (开始) → 32 (新增LinePtr)                    │
│ pd_upper = 7900 (开始)                                    │
│                                                             │
│ Offset 7900: (新创建的元组)                                 │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ HeapTupleHeader                                         │ │
│ │  t_xmin = 200  (新版本创建事务)                         │ │
│ │  t_xmax = 0    (未被删除)                               │ │
│ │  t_cid = 0                                             │ │
│ │  t_ctid = (0,1) (当前位置)                              │ │
│ │  t_infomask = HEAP_HASVARWIDTH                          │ │
│ │                                                         │ │
│ │ User Data:                                               │ │
│ │  name = 'Bob', age = 26  ← 更新的数据                     │ │
│ │  total: 27 bytes → LinePtr.length = 50                 │ │
│ └─────────────────────────────────────────────────────────┘ │
│                                                             │
│ 变化说明:                                                    │
│ - 新增 LinePtr[1] 指向新元组                                │
│ - 新元组的 t_xmin = 200 (创建者)                           │
│ - t_xmax = 0 (未被删除)                                    │
│ - t_ctid = (0,1) (指向自己)                                │
└─────────────────────────────────────────────────────────────┘

多个 UPDATE 的版本链:

┌─────────────────────────────────────────────────────────────┐
│ Version Chain:                                              │
│                                                             │
│ v0 (XID=100)                                               │
│ t_xmin=100, t_xmax=200, t_ctid=(0,1)                      │
│ data: name='Alice', age=25                                  │
│        ↓                                                   │
│ v1 (XID=200)                                               │
│ t_xmin=200, t_xmax=300, t_ctid=(0,2)                      │
│ data: name='Bob', age=26                                   │
│        ↓                                                   │
│ v2 (XID=300)                                               │
│ t_xmin=300, t_xmax=0, t_ctid=(0,2)                         │
│ data: name='Charlie', age=27                                │
│                                                             │
│ 查询时的遍历:                                               │
│ Seek: 从最新版本开始，根据可见性规则找到合适的版本          │
└─────────────────────────────────────────────────────────────┘
```

---

## 四、版本可见性规则

### 4.1 核心可见性判断流程

```
HeapTupleSatisfiesMVCC() 决策树:

开始判断: 元组 Tuple (t_xmin, t_xmax, etc)
    │
    ▼
┌─────────────────────────────────────────────────────────────┐
│                    步骤 1: 检查创建事务                      │
│ ←→ t_xmin 的事务状态                                        │
└─────────────────────────────────────────────────────────────┘
    │
    ├─ t_xmin < snapshot.xmin ( xmin 的值)                    │
    │   │                                                     │
    │   ▼                                                     │
    │ ┌─────────────────────────────────────────────────────┐ │
    │ │ Case 1: 创建事务在快照前启动                        │ │
    │ │        ↓                                          │ │
    │ │   检查事务提交状态:                                  │ │
    │ │   ├─ 如果已提交 ✓ → 继续 (到步骤2)                   │ │
    │ │   └─ 如果已中止 ✗ → 元组不可见                       │ │
    │ └─────────────────────────────────────────────────────┘ │
    │
    ├─ t_xmin == snapshot.xmin                             │
    │   │                                                     │
    │   ▼                                                     │
    │ ┌─────────────────────────────────────────────────────┐ │
    │ │ Case 2: 创建事务等于 xmin                           │ │
    │ │        ↓                                          │ │
    │ │   这个事务在拷贝快照时仍在运行                       │ │
    │ │   ├─ 如果是当前事务 ✓ → 元组可见                    │ │
    │ │   └─ 否则 ✗ → 元组不可见                            │ │
    │ └─────────────────────────────────────────────────────┘ │
    │
    ├─ t_xmin 在 snapshot.xip 中                             │
    │   │                                                     │
    │   ▼                                                     │
    │ ┌─────────────────────────────────────────────────────┐ │
    │ │ Case 3: 创建事务在快照时活跃                        │ │
    │ │        ↓                                          │ │
    │ │   └─ ✗ 元组不可见 (事务未提交)                      │ │
    │ └─────────────────────────────────────────────────────┘ │
    │
    ├─ t_xmin > snapshot.xmax                             │
    │   │                                                     │
    │   ▼                                                     │
    │ ┌─────────────────────────────────────────────────────┐ │
    │ │ Case 4: 创建事务在快照后启动                        │ │
    │ │        ↓                                          │ │
    │ │   └─ ✗ 元组不可见 (事务未开始)                      │ │
    │ └─────────────────────────────────────────────────────┘ │
    │
    ├─ 其他情况                                               │
    │   │                                                     │
    │   ▼                                                     │
    │ ┌─────────────────────────────────────────────────────┐ │
    │ │ Case 5: 创建事务已提交 (在快照范围内但不在活跃列表)    │ │
    │ │        ↓                                          │ │
    │ │   └─ ✓ 继续 (到步骤2)                               │ │
    │ └─────────────────────────────────────────────────────┘ │
    │
    ↓
步骤 1 结果: 元组可见 ✓ (继续检查删除状态)
    │
    ▼
┌─────────────────────────────────────────────────────────────┐
│                    步骤 2: 检查删除事务                      │
│ ←→ t_xmax 的事务状态                                        │
└─────────────────────────────────────────────────────────────┘
    │
    ├─ t_xmax == 0                                            │
    │   │                                                     │
    │   ▼                                                     │
    │ ┌─────────────────────────────────────────────────────┐ │
    │ │ Case A: 未被删除                                      │ │
    │ │        ↓                                          │ │
    │ │   └─ ✓ 元组可见 ✓ ✓                                  │ │
    │ └─────────────────────────────────────────────────────┘ │
    │
    ├─ t_xmax < snapshot.xmin                                │
    │   │                                                     │
    │   ▼                                                     │
    │ ┌─────────────────────────────────────────────────────┐ │
    │ │ Case B: 删除事务在快照前启动                        │ │
    │ │        ↓                                          │ │
    │ │   检查事务提交状态:                                  │ │
    │ │   ├─ 如果已提交 ✗ → 元组不可见                       │ │
    │ │   └─ 如果已中止 ✓ → 元组可见                        │ │
    │ └─────────────────────────────────────────────────────┘ │
    │
    ├─ t_xmax 在 snapshot.xip 中                              │
    │   │                                                     │
    │   ▼                                                     │
    │ ┌─────────────────────────────────────────────────────┐ │
    │ │ Case C: 删除事务在快照时活跃                        │ │
    │ │        ↓                                          │ │
    │ │   ├─ 如果是当前事务 ✗ → 元组不可见                  │ │
    │ │   └─ 否则 ✗ → 元组不可见                            │ │
    │ └─────────────────────────────────────────────────────┘ │
    │
    └─ (其他情况类似创建事务的判断)                           │
        │                                                     │
        ▼                                                     │
    ┌─────────────────────────────────────────────────────┐   │
    │ 最终结果 ✓                                           │   │
    └─────────────────────────────────────────────────────┘   │
```

### 4.2 可见性示例分析

```
具体示例分析:

场景设置:
┌─────────────────────────────────────────────────────────────┐
│ 时间线:                                                     │
│ T1: 事务100 开始                                            │
│ T2: 事务101 开始                                            │
│ T3: 事务100 记录快照，开始读取                                │
│ T4: 事务102 开始，插入数据                                   │
│ T5: 事务100 继续读取                                        │
│ T6: 事务101 删除数据，提交                                   │
│ T7: 事务100 继续读取                                        │
│ T8: 事务100 提交                                            │
└─────────────────────────────────────────────────────────────┘

事务100的快照 (T3时刻):
┌─────────────────────────────────────────────────────────────┐
│ 事务100 快照:                                               │
│ xmin = 99  (XID<99的都已提交)                               │
│ xmax = 103 (XID≥103的都未开始)                             │
│ xip = {100, 101} (当前活跃事务)                            │
│ curcid = 0                                                 │
└─────────────────────────────────────────────────────────────┘

各种元组的可见性判断:

情况 1: 事务99 创建的元组 (t_xmin=99, t_xmax=0)
┌─────────────────────────────────────────────────────────────┐
│ 元组:                                                       │
│ t_xmin = 99, t_xmax = 0                                    │
│                                                             │
│ 步骤1 (创建):                                               │
│ - t_xmin=99 < xmin=99? → 不成立 (等于)                      │
│ - t_xmin==xmin? 成立 → 检查:                              │
│   └─ 事务99 在快照前提交 ✓ → 继续                          │
│                                                             │
│ 步骤2 (删除):                                               │
│ - t_xmax=0 → 未被删除 ✓ → 元组可见 ✓ ✓                        │
│                                                             │
│ 结果: ✓ 可见                                               │
│ 原因: 在快照前已提交的元组                                  │
└─────────────────────────────────────────────────────────────┘

情况 2: 事务101 创建的元组 (t_xmin=101, t_xmax=0)
┌─────────────────────────────────────────────────────────────┐
│ 元组:                                                       │
│ t_xmin = 101, t_xmax = 0                                  │
│                                                             │
│ 步骤1 (创建):                                               │
│ - t_xmin=101 在 xip={100,101}中 → 创建事务活跃             │
│ - ✗ 元组不可见                                             │
│                                                             │
│ 结果: ✗ 不可见                                             │
│ 原因: 创建事务在快照时活跃                                  │
└─────────────────────────────────────────────────────────────┘

情况 3: 事务102 创建的元组 (t_xmin=102, t_xmax=0)
┌─────────────────────────────────────────────────────────────┐
│ 元组:                                                       │
│ t_xmin = 102, t_xmax = 0                                  │
│                                                             │
│ 步骤1 (创建):                                               │
│ - t_xmin=102 < xmin=99? 不成立                             │
│ - t_xmin> xmax=103? 不成立                                 │
│ - t_xmin 不在 xip 中                                       │
│ - ✓ 事务已提交 → 继续                                      │
│                                                             │
│ 步骤2 (删除):                                               │
│ - t_xmax=0 → 未被删除 ✓                                    │
│                                                             │
│ 结果: ✓ 可见                                               │
│ 原因: 在快照范围外但已提交                                  │
└─────────────────────────────────────────────────────────────┘

情况 4: 事务99 创建，事务101 删除的元组
        (t_xmin=99, t_xmax=101)
┌─────────────────────────────────────────────────────────────┐
│ 元组:                                                       │
│ t_xmin = 99, t_xmax = 101                                 │
│                                                             │
│ 步骤1 (创建):                                               │
│ - t_xmin=99 == xmin → 检查:                               │
│   └─ 事务99已提交 ✓ → 继续                                │
│                                                             │
│ 步骤2 (删除):                                               │
│ - t_xmax=101 在 xip={100,101}中 → 删除事务活跃             │
│ - ✗ 元组不可见                                             │
│                                                             │
│ 结果: ✗ 不可见                                             │
│ 原因: 删除事务在快照时活跃                                  │
└─────────────────────────────────────────────────────────────┘

情况 5: 事务100 自己创建的元组 (t_xmin=100, t_xmax=0)
┌─────────────────────────────────────────────────────────────┐
│ 元组:                                                       │
│ t_xmin = 100, t_xmax = 0                                  │
│                                                             │
│ 步骤1 (创建):                                               │
│ - t_xmin=100 在 xip 中 → 创建事务活跃                     │
│ - 但 t_xmin == 当前事务ID ✓ → 元组可见                    │
│                                                             │
│ 步骤2 (删除):                                               │
│ - t_xmax=0 → 未被删除 ✓                                    │
│                                                             │
│ 结果: ✓ 可见                                               │
│ 原因: 自己创建的元组，即使事务未完成也可见                   │
└─────────────────────────────────────────────────────────────┘
```

---

## 五、MVCC 的优势

### 5.1 并发性能优势

```
传统锁定 vs MVCC 并发性能对比:

传统锁定方式的瓶颈:
┌─────────────────────────────────────────────────────────────┐
│ 场景: 100个并发操作 (50读 + 50写)                          │
│                                                             │
│ 传统方式:                                                  │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ 时间轴                                                   │ │
│ │ T0 ──┐                                                   │ │
│ │      │ Readers[1..50] 需要共享锁                       │ │
│ │      │ - 但写者们需要排他锁                             │ │
│ │      │ - 只能有1个读者或1个写者同时执行                  │ │
│ │ T10 ─┘                                                   │ │
│ │ T10 ──┐                                                   │ │
│ │       │ Writers[1..50] 串行执行                           │ │
│ │       │ - 每个写者等待前面的完成                          │ │
│ │       │ - 总时间 = 50 × 写操作时间                        │ │
│ │ T100┘                                                   │ │
│ │                                                           │ │
│ │ 问题:                                                    │ │
│ │ - 读互相等待                                               │ │
│ │ - 读写冲突                                                │ │
│ │ - 死锁风险                                                │ │
│ │ -吞吐量极低                                               │ │
│ └─────────────────────────────────────────────────────────┘ │
│                                                             │
│ MVCC 方式:                                                 │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ 时间轴                                                   │ │
│ │ T0  ──┐                                                  │ │
│ │       │ Readers[1..50] 并发执行                         │ │
│ │       │ - 每个读者有自己的快照                            │ │
│ │       │ - 无锁访问                                        │ │
│ │       │ - 真正的并行执行                                  │ │
│ │ T2  ──┘                                                  │ │
│ │                                                             │ │
│ │ T0  ──┐                                                  │ │
│ │       │ Writers[1..50] 并发执行                         │ │
│ │       │ - 创建新版本，不阻塞读者                          │ │
│ │       │ - 版本管理并行                                    │ │
│ │ T10 ──┘                                                  │ │
│ │                                                             │ │
│ │ 优势:                                                    │ │
│ │ - 读者不互相阻塞                                           │ │
│ │ - 读写不阻塞                                              │ │
│ │ - 无死锁                                                  │ │
│ │ - 吞吐量高                                                │ │
│ └─────────────────────────────────────────────────────────┘ │
│                                                             │
│ 性能对比:                                                  │
│ 传统锁定: 总耗时 ≈ 100 单位时间                             │
│ MVCC:     总耗时 ≈ 10 单位时间                              │
│ 性能提升: 10倍                                             │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 数据一致性优势

```
MVCC 保证的一致性:

可重复读 (Repeatable Read):
┌─────────────────────────────────────────────────────────────┐
│ 事务 A: SELECT balance FROM accounts WHERE id=1             │
│                                                            │
│ T1: 开始事务，创建快照                                     │
│    ├── 快照 xmin=100, xmax=105                             │
│    ├── 读取 balance = $1000                                │
│                                                            │
│ (其他事务在 T2-T6 之间修改了数据)                           │
│ T2: 事务B UPDATE balance += 200  → $1200                   │
│ T3: 事务B 提交                                              │
│ T4: 事务C UPDATE balance -= 100  → $1100                   │
│ T5: 事务C 提交                                              │
│                                                            │
│ T7: 事务A 再次查询                                         │
│    └─ 使用相同快照，仍看到 balance = $1000 ✓                  │
│                                                            │
│ 结果: 可重复读 ✓                                            │
└─────────────────────────────────────────────────────────┘

读已提交 (Read Committed):
┌─────────────────────────────────────────────────────────────┐
│ 事务 A: SELECT balance FROM accounts WHERE id=1             │
│                                                            │
│ T1: 开始事务                                               │
│    ├── 无持久快照                                          │
│    ├── 读取 balance = $1000                                │
│                                                            │
│ T2: 事务B UPDATE balance += 200  → $1200                   │
│ T3: 事务B 提交 ✓                                           │
│                                                            │
│ T4: 事务A 再次查询                                         │
│    └─ 获取新快照，读到 balance = $1200                      │
│                                                            │
│ 结果: 读已提交 ✓                                            │
│ 解释: 每条语句获取新快照                                  │
└─────────────────────────────────────────────────────────────┘

幻读保护:
┌─────────────────────────────────────────────────────────────┐
│ 事务 A: SELECT COUNT(*) FROM orders WHERE amount > 100      │
│                                                            │
│ T1: 开始事务，创建快照                                     │
│    ├── 读取 count = 10                                     │
│                                                            │
│ T2: 事务B INSERT INTO orders VALUES (...) (amount=150)    │
│ T3: 事务B 提交 ✓                                           │
│                                                            │
│ T4: 事务A 再次查询                                         │
│    └─ 使用相同快照，仍看到 count = 10                        │
│                                                            │
│ 结果: 无幻读 ✓                                             │
│ 原因: PostgreSQL 在 REPEATABLE READ 隔离级别上实现           │
│      了无幻读保护 (通过谓词锁和 MVCC)                       │
└─────────────────────────────────────────────────────────────┘
```

---

## 六、与其它并发控制方式对比

### 6.1 三种并发控制方式对比

```
并发控制方式对比:

┌─────────────────────────────────────────────────────────────┐
│                         并发控制对比表                        │
├─────────────┬─────────────────┬─────────────────┬─────────────┤
│             │   传统锁定方式    │      MVCC       │   混合方式   │
├─────────────┼─────────────────┼─────────────────┼─────────────┤
│ 读写冲突     │     高           │      无          │     中       │
│             │                 │                 │             │
│ 原理:        │ 读阻塞写，写阻塞读│ 读写并发执行    │ 小范围锁     │
│             |                 │                 │ + MVCC      │
├─────────────┼─────────────────┼─────────────────┼─────────────┤
│ 读读冲突     │     中           │      无          │      无      │
│             │                 │                 │             │
│ 原理:        │ 共享锁可能互斥    │ 无锁访问        │ 无锁访问     │
│             │ (某些实现)       │                 │             │
├─────────────┼─────────────────┼─────────────────┼─────────────┤
│ 写写冲突     │     高           │      中          │      中      │
│             │                 │                 │             │
│ 原理:        │ 串行执行         │ 版本化处理      │ 检测冲突    │
│             │                 │                 │ + 回滚      │
├─────────────┼─────────────────┼─────────────────┼─────────────┤
│ 死锁风险     │     高           │      无          │      低      │
│             │                 │                 │             │
│ 原理:        | 锁顺序可能导致   │ 无锁机制        │ 锁粒度小     │
│             │ 循环等待         │                 │             │
├─────────────┼─────────────────┼─────────────────┼─────────────┤
│ 内存开销     │     低           │      高          │      中      │
│             │                 │                 │             │
│ 原理:        │ 只维护事务表     │ 维护多版本数    │ 维护部分版本  │
│             │                 │ 据和元数据      │             │
├─────────────┼─────────────────┼─────────────────┼─────────────┤
│ 一致性级别   │   可配置         │   读已提交/     │   可配置     │
│             │                 │   可重复读       │             │
│ 性能特征     │ 吞吐量低         │ 高吞吐量        │ 中等吞吐量   │
│             │ 读写等待严重     │ 读写并发高       │ 适中平衡      │
└─────────────┴─────────────────┴─────────────────┴─────────────┘

适用场景分析:

传统锁定方式适用:
├─ 写密集型应用
├─ 数据完整性要求极高
├─ 事务持续时间短
└─ 并发用户数较少

MVCC 适用:
├─ 混合读写应用 (OLTP)
├─ 读多写少应用
├─ 并发用户数多
└─ 需要高吞吐量

混合方式适用:
├─ 特定冲突点多
├─ 需要细粒度控制
├─ 性能和平衡要求
└─ 复杂业务逻辑
```

### 6.2 PostgreSQL MVCC 的独特优势

```
PostgreSQL MVCC 特有优势:

1. 真正的多读并发:
┌─────────────────────────────────────────────────────────────┐
│ 传统数据库 (如 MySQL InnoDB):                              │
│ - SELECT 加共享锁 (在某些隔离级别)                          │
│ - 可能出现读阻塞                                           │
│                                                             │
│ PostgreSQL:                                                 │
│ - SELECT 完全无锁                                           │
│ - 多读者真正并行                                           │
│ - 基于快照的一致性读取                                      │
└─────────────────────────────────────────────────────────────┘

2. HOT (Heap-Only Tuple) 优化:
┌─────────────────────────────────────────────────────────────┐
│ 场景: UPDATE 不改变索引列                                   │
│                                                             │
│ 传统方式:                                                  │
│ 1. 更新 HEAP 数据页                                        │
│ 2. 更新所有相关索引页                                       │
│ 3. 写日志开销大                                            │
│                                                             │
│ PostgreSQL HOT 优化:                                       │
│ 1. 更新 HEAP 数据页 (在同页面写入新版本)                    │
│ 2. 索引页无需更新 (指针继续指向旧位置)                       │
│ 3. t_ctid 重定向到新版本                                    │
│ 4. 写日志开销减少 60-80%                                    │
│                                                             │
│ 具体流程:                                                  │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ 原始数据 (同一页面内):                                    │ │
│ │ Tuple_A (LinePtr 1): name='Alice', age=25               │ │
│ │ Index Entry: key=1 → (Page 0, LinePtr 1)                │ │
│ │                                                           │ │
│ │ HOT UPDATE:                                              │ │
│ │ Tuple_A (LinePtr 1): t_xmax=100, t_ctid指向(0,2)        │ │
│ │ Tuple_B (LinePtr 2): name='Alice', age=26, t_xmin=100  │ │
│ │ Index Entry 保持不变: key=1 → (Page 0, LinePtr 1) ✓       │ │
│ │                                                           │ │
│ │ 查询:                                                      │ │
│ │ 1. 索引查找 → (Page 0, LinePtr 1)                        │ │
│ │ 2. 读取 Tuple_A → t_ctid指向(0,2)                         │ │
│ │ 3. 直接跳转到 Tuple_B → 最新版本                           ← HOT优化 │
│ │ 4. 无需重新查找索引                                        │ │
│ └─────────────────────────────────────────────────────────┘ │
│                                                             │
│ 优势:                                                      │
│ - 减少 60% 的索引更新                                       │
│ - 提高 UPDATE 性能                                         │
│ - 减少 WAL 日志                                            │
│ - 降低索引碎片                                              │
└─────────────────────────────────────────────────────────────┘

3. 隔离级别实现:
┌─────────────────────────────────────────────────────────────┐
│ PostgreSQL 提供三种隔离级别:                                  │
│                                                             │
│ 1. READ COMMITTED (读已提交)                                │
│    └─ 每条语句获取新快照                                    │
│    └─ 防止脏读                                              │
│                                                             │
│ 2. REPEATABLE READ (可重复读) - 默认                         │
│    └─ 事务开始时获取快照                                      │
│    └─ 防止脏读、不可重复读、幻读                             │
│                                                             │
│ 3. SERIALIZABLE (可串行化)                                  │
│    └─ 基于可重复读 + 谓词锁                                  │
│    └─ 完全串行化执行                                         │
│                                                             │
│ 特点:                                                      │
│ - 默认级别是 REPEATABLE READ (比其他数据库更高)              │
│ - 真正实现无幻读                                            │
│ - 提供强一致性保证                                          │
└─────────────────────────────────────────────────────────────┘
```

---

## 总结

MVCC 是 PostgreSQL 最核心的创新之一，从根本上改变了数据库的并发处理方式：

### 核心价值

1. **读写并发**: 真正的读写不阻塞，极大提升并发性能
2. **一致性保证**: 通过快照机制提供强大的一致性保证
3. **死锁避免**: 无锁机制天然避免死锁问题
4. **性能优化**: HOT 等优化技术进一步提升性能

### 关键机制

1. **事务快照**: 为每个事务提供一致的数据视图
2. **版本链**: 通过 t_xmin/t_xmax 构建数据版本历史
3. **可见性规则**: 复杂但精确的版本可见性判断
4. **元数据管理**: 高效的事务状态缓存和查询

### 与众不同

1. **真正的多读并发**: SELECT 完全无锁
2. **更强的默认隔离**: REPEATABLE READ 作为默认级别
3. **HOT 优化**: 同页 UPDATE 高效处理
4. **无死锁架构**: 从根本上避免死锁

**下一步**: 深入学习 MVCC 的核心数据结构和实现细节。

---

**文档版本**: 1.0
**相关源码**: PostgreSQL 17.5
**创建日期**: 2025-01-15

**下一篇**: [02_data_structures.md](02_data_structures.md) - MVCC 核心数据结构详解
