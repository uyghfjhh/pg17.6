# WAL (Write-Ahead Log) 模块概述

> WAL 是 PostgreSQL 数据持久化的基石，确保 ACID 特性中的原子性和持久性。

---

## 目录

1. [WAL 核心概念](#一wal-核心概念)
2. [WAL 系统架构](#二wal-系统架构)
3. [核心数据结构概览](#三核心数据结构概览)
4. [WAL 记录生命周期](#四wal-记录生命周期)
5. [关键组件说明](#五关键组件说明)
6. [WAL 的重要性](#六wal-的重要性)

---

## 一、WAL 核心概念

### 1.1 什么是 WAL？

**Write-Ahead Logging (WAL)** 是一种确保数据持久性的关键技术：

```
修改顺序：
1. 先写 WAL 记录 (到 WAL 缓冲区)
2. 再修改数据页面 (在 Buffer Pool 中)
3. 最后刷写 WAL 到磁盘 (确保持久化)

这个顺序确保：即使系统崩溃，也能通过 WAL 恢复所有已提交的事务
```

### 1.2 WAL 的核心价值

| 特性 | 说明 | 实现机制 |
|------|------|----------|
| **原子性** | 事务要么全部成功，要么全部失败 | 通过 WAL 记录所有修改 |
| **持久性** | 已提交事务永不丢失 | WAL 刷盘后才确认提交 |
| **崩溃恢复** | 系统崩溃后能恢复到一致状态 | 重做 WAL 记录 |
| **时间点恢复** | 可恢复到任意时间点 | WAL 归档 + 基础备份 |
| **流复制** | 主备同步的基础 | 发送 WAL 到备库 |

### 1.3 WAL vs 传统的 Redo/Undo

```
传统方式 (Undo + Redo):
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   Undo Log  │    │  Data Page  │    │   Redo Log  │
│ (回滚日志)   │ ←→ │   (数据页)   │ ←→ │ (重做日志)   │
└─────────────┘    └─────────────┘    └─────────────┘
     ↑                  ↑                  ↑
   回滚用             主存储             恢复用

PostgreSQL WAL (仅 Redo):
┌─────────────┐    ┌─────────────┐
│   WAL Log   │    │  Data Page  │
│ (仅重做日志) │ ←→ │ (多版本数据) │
└─────────────┘    └─────────────┘
     ↑                  ↑
   持久化+恢复          MVCC处理回滚
```

---

## 二、WAL 系统架构

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                     WAL 系统架构                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
         ┌────────────────────┴────────────────────┐
         │                                         │
         ▼                                         ▼
┌──────────────────────┐              ┌──────────────────────┐
│   WAL 生成层         │              │   WAL 消费层         │
│   (XLogInsert)       │              │   (XLogRead)         │
└──────────┬───────────┘              └──────────┬───────────┘
           │                                    │
    ┌──────┴──────┐                     ┌────────┴────────┐
    ▼             ▼                     ▼                 ▼
┌──────────┐ ┌──────────┐         ┌──────────┐     ┌──────────┐
│Backend   │ │Backend   │         │WAL Writer│     │Startup   │
│Process 1 │ │Process 2 │         │Process   │     │Process   │
└──────────┘ └──────────┘         └──────────┘     └──────────┘
     │             │                     │                 │
     └─────────────┼─────────────────────┼─────────────────┘
                   │                     │
                   ▼                     ▼
            ┌────────────────┐   ┌────────────────┐
            │  WAL Buffers   │   │   WAL Files    │
            │   (内存)       │   │   (磁盘)       │
            │ 16MB (默认)    │   │  16MB/段文件   │
            └────────┬───────┘   └────────┬───────┘
                     │                    │
                     ▼                    ▼
              ┌──────────────┐    ┌──────────────┐
              │ WAL Writer   │    │ WAL Files    │
              │ (异步刷盘)    │    │ 0000000100... │
              └──────────────┘    └──────────────┘
```

### 2.2 WAL 数据流全景

```
事务修改流程
┌───────────────────────────────────────────────────────────────┐
│ 1. Backend 进程执行 SQL                                        │
│    INSERT INTO t VALUES (1, 'data');                           │
└───────────────────┬───────────────────────────────────────────┘
                    │
                    ▼
┌───────────────────────────────────────────────────────────────┐
│ 2. 生成 WAL 记录                                               │
│    XLogInsert(RM_HEAP_ID, XLOG_HEAP_INSERT, &data)            │
│    返回 LSN: 0/1A000128                                        │
└───────────────────┬───────────────────────────────────────────┘
                    │
                    ▼
┌───────────────────────────────────────────────────────────────┐
│ 3. 复制到 WAL 缓冲区                                            │
│    WALInsertLock 获取锁                                        │
│    复制记录到 XLogCtl->pages                                   │
│    更新 InsertPtr (插入指针)                                   │
│    释放 WALInsertLock                                          │
└───────────────────┬───────────────────────────────────────────┘
                    │
                    ▼
┌───────────────────────────────────────────────────────────────┐
│ 4. 修改数据页面                                                │
│    ReadBuffer() → 修改页面 → MarkBufferDirty()                │
│    将 LSN (0/1A000128) 记录在页面头部                          │
└───────────────────┬───────────────────────────────────────────┘
                    │
                    ▼
┌───────────────────────────────────────────────────────────────┐
│ 5. 事务提交                                                     │
│    XLogFlush(InsertPtr) 确保 WAL 持久化                         │
│    如果 WAL Writer 未刷盘，触发刷盘                            │
│    等待 WAL 刷到磁盘                                            │
└───────────────────┬───────────────────────────────────────────┘
                    │
                    ▼
┌───────────────────────────────────────────────────────────────┐
│ 6. WAL Writer 异步工作                                          │
│    周期性检查 WAL 缓冲区                                       │
│    调用 XLogWrite() 刷写到磁盘                                 │
│    更新 FlushPtr (刷盘指针)                                    │
└───────────────────────────────────────────────────────────────┘
```

---

## 三、核心数据结构概览

### 3.1 XLogCtlData (WAL 全局控制)

**源码**: `src/backend/access/transam/xlog.c:650`

```c
typedef struct XLogCtlData
{
    // WAL 缓冲区控制
    XLogRecPtr    Insert;           // 插入指针 (全局)
    XLogRecPtr    Flush;            // 刷盘指针 (已持久化)
    
    // WAL 缓冲区 (环形缓冲区)
    char         *pages;            // WAL 缓冲区指针
    XLogRecPtr    LogwrtResult;     // 最近写入结果
    
    // 页面状态数组
    XLogPageWriteState *page_state; // 每个页面的写入状态
    
    // WAL 插入锁 (多进程并发插入)
    LWLockPadded   WALInsertLocks[NUM_XLOGINSERT_LOCKS];
    
    // 统计信息
    XLogStats     *wal_stats;       // WAL 统计
    
    // 复制相关
    List         *archive_queue;    // 归档队列
    
} XLogCtlData;
```

### 3.2 XLogRecord (WAL 记录)

**源码**: `src/include/access/xlogrecord.h:50`

```c
typedef struct XLogRecord
{
    uint32     xl_tot_len;      // 记录总长度 (包括头)
    TransactionId xl_xid;       // 事务 ID
    XLogRecPtr xl_prev;         // 上一条记录的 LSN
    uint8      xl_info;         // 标志位 + 资源管理器信息
    RmgrId     xl_rmid;         // 资源管理器 ID
    pg_crc32c  xl_crc;          // CRC32C 校验和
    
    // 变长数据紧随其后
} XLogRecord;
```

### 3.3 XLogRecPtr (LSN 类型)

**源码**: `src/include/access/xlogdefs.h:12`

```c
typedef uint64 XLogRecPtr;

// LSN = Log Sequence Number (日志序列号)
// 48 位有效，格式: 高 32 位 = 段文件号，低 32 位 = 段内偏移

#define InvalidXLogRecPtr   ((XLogRecPtr) 0)
#define XLogRecPtrIsInvalid(r)  ((r) == InvalidXLogRecPtr)
```

---

## 四、WAL 记录生命周期

### 4.1 记录生成 → 持久化 → 消费

```
┌─────────────────────────────────────────────────────────────────┐
│                     WAL 记录生命周期                             │
└─────────────────────────────────────────────────────────────────┘

阶段 1: 生成 (Backend 进程)
┌─────────────────────────────────────────────────────────────────┐
│ Backend Process                                                 │
│ ┌─────────────────────────────────────────────────────────────┐ │
│ │ 1. 构造 WAL 记录                                            │ │
│ │    - 确定资源管理器 (RM_xxx)                                │ │
│ │    - 填充数据内容                                           │ │
│ │                                                             │ │
│ │ 2. 调用 XLogInsert()                                        │ │
│ │    - 获取 XLogInsertLock                                    │ │
│ │    - 计算 LSN                                               │ │
│ │    - 复制到 WAL 缓冲区                                      │ │
│ │    - 更新 InsertPtr                                         │ │
│ │                                                             │ │
│ │ 3. 返回 LSN 给调用者                                         │ │
│ └─────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼

阶段 2: 缓冲 (WAL 缓冲区)
┌─────────────────────────────────────────────────────────────────┐
│ WAL Buffers (16MB 环形缓冲区)                                  │
│                                                                 │
│  [Record 1] [Record 2] ... [Record N] [Free Space]              │
│     ↑                                          ↑                │
│   InsertPtr                                   LogwrtResult     │
│   (插入位置)                                 (写入位置)         │
│                                                                 │
│ 注: 如果缓冲区空间不足，需要等待 WAL Writer 释放空间              │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼

阶段 3: 刷盘 (WAL Writer 进程)
┌─────────────────────────────────────────────────────────────────┐
│ WAL Writer Process                                              │
│ ┌─────────────────────────────────────────────────────────────┐ │
│ │ 1. 检查 WAL 缓冲区                                          │ │
│ │    wal_writer_delay (默认 200ms)                            │ │
│ │                                                             │ │
│ │ 2. 如果有新数据，调用 XLogWrite()                           │ │
│ │    - 计算需要写入的页面范围                                  │ │
│ │    - 调用 write() 系统调用                                   │ │
│ │    - 处理写入错误                                            │ │
│ │                                                             │ │
│ │ 3. 更新 FlushPtr                                             │ │
│ │    记录哪些 LSN 已持久化                                     │ │
│ └─────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼

阶段 4: 归档 (Archiver 进程 - 可选)
┌─────────────────────────────────────────────────────────────────┐
│ WAL Archiver Process                                           │
│ ┌─────────────────────────────────────────────────────────────┐ │
│ │ 1. 检测已完成的 WAL 段文件                                   │ │
│ │    当 .done 文件出现时                                       │ │
│ │                                                             │ │
│ │ 2. 调用 archive_command                                       │ │
│ │    archive_command = 'cp %p /archive/%f'                   │ │
│ │                                                             │ │
│ │ 3. 将 .done 文件重命名为 .ready                              │ │
│ └─────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼

阶段 5: 消费 (多种消费者)
┌─────────────────────────────────────────────────────────────────┐
│                          消费者                                │
├──────────────────┬──────────────────┬──────────────────────────┤
│  Startup Process │   WAL Sender     │   PITR 恢复              │
│  (崩溃恢复)       │   (流复制)       │   (时间点恢复)            │
│                  │                  │                          │
│ - 读取 WAL       │ - 发送 WAL       │ - 读取归档 WAL            │
│ - 重放记录       │ - 同步到备库     │ - 应用到恢复点            │
│ - 重建数据页面   │ - 保持主备一致   │ - 打开数据库              │
└──────────────────┴──────────────────┴──────────────────────────┘
```

---

## 五、关键组件说明

### 5.1 进程角色

| 进程 | 源码位置 | 职责 | 数量 |
|------|----------|------|------|
| **Backend** | XLogInsert() | 生成 WAL 记录 | N |
| **WAL Writer** | postmaster/walwriter.c | 异步刷写 WAL | 1 |
| **Archiver** | postmaster/pgarch.c | 归档 WAL 文件 | 0-1 |
| **WAL Sender** | replication/walsender.c | 发送 WAL 到备库 | 0-N |
| **Startup** | access/transam/xlog.c | 崩溃恢复时重放 WAL | 0-1 |

### 5.2 关键函数

| 函数 | 源码位置 | 作用 |
|------|----------|------|
| **XLogInsert** | xlog.c:1230 | 插入 WAL 记录到缓冲区 |
| **XLogFlush** | xlog.c:2500 | 确保 WAL 持久化到磁盘 |
| **XLogWrite** | xlog.c:2700 | 实际写入 WAL 到文件 |
| **ReadRecord** | xlog.c:6000 | 从 WAL 文件读取记录 |
| **StartupXLOG** | xlog.c:5000 | 崩溃恢复主函数 |

### 5.3 配置参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| **wal_buffers** | 16MB | WAL 缓冲区大小 |
| **wal_writer_delay** | 200ms | WAL Writer 唤醒间隔 |
| **wal_sync_method** | fdatasync | WAL 刷盘方法 |
| **wal_level** | replica | WAL 记录详细程度 |
| **max_wal_size** | 1GB | WAL 文件最大总大小 |
| **min_wal_size** | 80MB | WAL 文件最小总大小 |

---

## 六、WAL 的重要性

### 6.1 为什么 WAL 如此重要？

#### 6.1.1 数据安全
```
场景：系统突然断电

无 WAL:
┌─────────────┐    ┌─────────────┐
│  数据修改    │ →  │  系统断电   │ → ┌─────────────┐
│  (内存中)    │    │             │   │  数据不一致  │
└─────────────┘    └─────────────┘   └─────────────┘

有 WAL:
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  数据修改    │ →  │  WAL 持久化 │ →  │  系统断电   │
│  (内存中)    │    │             │    │             │
└─────────────┘    └─────────────┘    └─────────────┘
                                            ↓
                                    ┌─────────────┐
                                    │  重放 WAL   │ → │  数据恢复   │
                                    └─────────────┘   └─────────────┘
```

#### 6.1.2 高可用性
```
主备同步依赖于 WAL:

主库:              备库:
┌─────────────┐   →   ┌─────────────┐
│ WAL 记录     │       │ 接收 WAL    │
│ (本地写入)    │       │ (网络传输)   │
└─────────────┘       └─────────────┘
    │                      │
    ↓                      ↓
┌─────────────┐       ┌─────────────┐
│ 发送给备库   │ ←     │ 重放 WAL    │
│ (WAL Sender) │       │ (Startup)   │
└─────────────┘       └─────────────┘
```

### 6.2 WAL 的性能影响

#### 6.2.1 写入瓶颈
```
传统同步写入:
Backend → 直接写 WAL 文件 → fsync() (慢)

PostgreSQL 优化:
Backend → 写 WAL 缓冲区 (快)
       → WAL Writer 异步刷写 (后台)
       → 必要时才同步 fsync() (事务提交时)
```

#### 6.2.2 组提交 (Group Commit)
```
多个事务同时提交:

T1: XLogFlush()
T2: XLogFlush()  → 等待
T3: XLogFlush()  → 等待
    ↓ WAL Writer 刷一次盘
T1, T2, T3: 全部唤醒 (共享一次 fsync)

效果: 分摊 fsync 成本
```

---

## 总结

WAL 是 PostgreSQL 数据持久化的核心技术，确保了：

1. **ACID 特性**: 原子性和持久性
2. **崩溃恢复**: 系统异常后能恢复到一致状态
3. **复制基础**: 主备同步和逻辑复用的基础
4. **时间点恢复**: 配合归档实现 PITR

**关键优势**:
- 顺序 I/O: WAL 是顺序写入，性能好
- 批量优化: 组提交减少 fsync 次数
- 异步处理: WAL Writer 减少主进程阻塞

**下一步**: 深入学习 WAL 的核心数据结构实现细节。

---

**文档版本**: 1.0
**相关源码**: PostgreSQL 17.5
**创建日期**: 2025-01-15

**下一篇**: [02_data_structures.md](02_data_structures.md) - WAL 核心数据结构详解
