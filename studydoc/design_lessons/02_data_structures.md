# 数据结构设计艺术

> 从PostgreSQL学习如何选择和设计数据结构

**版本**: PostgreSQL 17.6  
**最后更新**: 2025-10-17

---

## 目录

1. [B+树索引设计](#1-b树索引设计)
2. [动态哈希表 (dynahash)](#2-动态哈希表dynahash)
3. [共享内存池](#3-共享内存池)
4. [Clock-Sweep缓存](#4-clock-sweep缓存)
5. [链表和双向链表](#5-链表和双向链表)
6. [位图集合 (Bitmapset)](#6-位图集合bitmapset)
7. [设计原则总结](#7-设计原则总结)

---

## 1. B+树索引设计

### 1.1 为什么选择B+树？

**对比常见数据结构**:
```
二叉搜索树 (BST):
       50
      /  \
    30    70
   / \    / \
  20 40  60  80

✅ 查找: O(log n)
❌ 不平衡时退化为O(n)
❌ 磁盘I/O次数多 (每个节点一次I/O)

平衡二叉树 (AVL/红黑树):
✅ 保证平衡: O(log n)
❌ 磁盘I/O次数仍然多
❌ 每个节点存储数据少

B+树:
✅ 每个节点存储多个键值 (高扇出)
✅ 只需要少量I/O
✅ 叶子节点链式连接 (范围查询高效)
✅ 所有数据在叶子节点 (查询稳定)
```

### 1.2 PostgreSQL B+树结构

```
B+树整体结构:
                    ┌─────────────────┐
                    │   Meta Page     │  ← Page 0
                    │   (根节点指针)   │
                    └────────┬────────┘
                             │
                    ┌────────┴────────┐
                    │   Root Page     │  ← 根节点
                    │  [50 | 100]     │
                    └───┬────────┬────┘
                        │        │
          ┌─────────────┘        └─────────────┐
          │                                    │
    ┌─────┴──────┐                       ┌────┴──────┐
    │ Inner Page │                       │Inner Page │
    │[25|35|45]  │                       │[75|85|95] │
    └─┬───┬───┬──┘                       └─┬───┬───┬─┘
      │   │   │                            │   │   │
      └───┼───┼────────────────────────────┼───┼───┘
          │   └────────────────────────────┘   │
          ↓                                    ↓
    ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
    │Leaf Page│→ │Leaf Page│→ │Leaf Page│→ │Leaf Page│
    │[20,22,..]  │[30,32,..]  │[75,78,..]  │[95,97,..]
    │ + Tuple │  │ + Tuple │  │ + Tuple │  │ + Tuple │
    │   TIDs  │  │   TIDs  │  │   TIDs  │  │   TIDs  │
    └─────────┘  └─────────┘  └─────────┘  └─────────┘

叶子节点双向链表 (支持范围扫描)
```

### 1.3 Page内部结构

```
B+树页面布局 (8KB):
┌──────────────────────────────────────────────────┐
│                 Page Header                       │  ← 24 bytes
│  ┌────────────────────────────────────────────┐ │
│  │ pd_lsn: WAL位置                            │ │
│  │ pd_checksum: 校验和                        │ │
│  │ pd_flags: 页面标志                         │ │
│  │ pd_lower: 空闲空间开始                     │ │
│  │ pd_upper: 空闲空间结束                     │ │
│  │ pd_special: 特殊空间指针                   │ │
│  └────────────────────────────────────────────┘ │
├──────────────────────────────────────────────────┤
│              Item Pointers Array                  │  ← 行指针数组
│  ┌──────┬──────┬──────┬──────┬──────┬──────┐   │
│  │Item1 │Item2 │Item3 │Item4 │Item5 │Item6 │   │
│  │offset│offset│offset│offset│offset│offset│   │
│  └──────┴──────┴──────┴──────┴──────┴──────┘   │
├──────────────────────────────────────────────────┤
│                                                   │
│            Free Space (空闲空间)                  │
│                                                   │
├──────────────────────────────────────────────────┤
│                  Index Tuples                     │  ← 实际数据
│  ┌────────────────┐  ┌────────────────┐         │
│  │ Key: 50        │  │ Key: 30        │         │
│  │ TID: (1, 10)   │  │ TID: (1, 5)    │         │
│  └────────────────┘  └────────────────┘         │
│            ... 更多 Index Tuples ...              │
├──────────────────────────────────────────────────┤
│               Special Space                       │  ← B树特殊数据
│  ┌────────────────────────────────────────────┐ │
│  │ btpo_prev: 前一个叶子页面                  │ │
│  │ btpo_next: 后一个叶子页面                  │ │
│  │ btpo_level: 树的层级                       │ │
│  │ btpo_flags: 页面类型 (叶子/内部节点)      │ │
│  └────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────┘
```

### 1.4 B+树查找过程

```
查找Key=75的过程:
┌────────────────────────────────────────────────────┐
│ Step 1: 从根节点开始                                │
│  Root: [50 | 100]                                  │
│  75 > 50 且 75 < 100                               │
│  → 走右子树                                         │
└────────────────────┬───────────────────────────────┘
                     ↓
┌────────────────────────────────────────────────────┐
│ Step 2: 遍历内部节点                                │
│  Inner: [75 | 85 | 95]                             │
│  75 == 75                                          │
│  → 走第一个子树                                     │
└────────────────────┬───────────────────────────────┘
                     ↓
┌────────────────────────────────────────────────────┐
│ Step 3: 到达叶子节点                                │
│  Leaf: [75, 76, 77, 78, ...]                       │
│  找到Key=75 → 返回TID                              │
└────────────────────────────────────────────────────┘

I/O次数: 3次 (假设3层树)
对比: 红黑树可能需要log2(n)次，数据量大时差异巨大
```

### 1.5 B+树插入和分裂

```
插入导致页面分裂:
插入前 (页面满):
┌──────────────────────────────────────┐
│ Leaf Page (满)                        │
│ [10, 20, 30, 40, 50, 60, 70, 80, 90] │
└──────────────────────────────────────┘

插入Key=45:
┌────────────────────┐     ┌────────────────────┐
│ Left Page          │  ←→ │ Right Page         │
│ [10, 20, 30, 40]   │     │ [45, 50, 60, 70, 80│
└────────────────────┘     └────────────────────┘
         ↑                           ↑
         └─────────┬─────────────────┘
                   │
          父节点更新: 插入分割键45

分裂策略:
✅ 中间分裂 (默认)
✅ 右侧分裂 (顺序插入优化)
✅ 延迟分裂 (HOT优化)
```

### 1.6 设计原则

**原则1: 减少I/O是王道**
```
为什么不用哈希索引做主索引?
- 哈希索引范围查询差
- B+树虽然查询略慢，但适用性广

为什么不用跳表?
- 跳表的指针开销大
- B+树更compact，缓存友好
```

**原则2: 顺序I/O优化**
```
叶子节点链式连接 → 范围扫描变成顺序I/O
```

**原则3: 空间局部性**
```
一个Page存储多个键值
一次I/O读入多个键 → 提高缓存命中率
```

---

## 2. 动态哈希表 (dynahash)

### 2.1 PostgreSQL的哈希表需求

**问题**: 
- 共享内存中需要哈希表 (如Buffer Hash Table)
- 数据量未知，需要动态扩展
- 多进程并发访问，需要线程安全

### 2.2 dynahash结构

```
动态哈希表整体结构:
┌──────────────────────────────────────────────────┐
│            HTAB (哈希表控制块)                    │
│  ┌────────────────────────────────────────────┐ │
│  │ hctl: 哈希表控制信息                       │ │
│  │   - num_entries: 当前条目数                │ │
│  │   - max_bucket: 当前bucket数               │ │
│  │   - high_mask / low_mask: 哈希掩码         │ │
│  │ hash: 哈希函数                             │ │
│  │ match: 比较函数                            │ │
│  │ keycopy: 键拷贝函数                        │ │
│  └────────────────────────────────────────────┘ │
└────────────────────┬─────────────────────────────┘
                     │
        ┌────────────┴───────────┐
        ↓                        ↓
┌─────────────┐          ┌─────────────┐
│ Segment 0   │          │ Segment 1   │
│             │          │             │
│ ┌─────────┐ │          │ ┌─────────┐ │
│ │Bucket 0 │ │          │ │Bucket N │ │
│ └────┬────┘ │          │ └────┬────┘ │
│      │      │          │      │      │
│      ↓      │          │      ↓      │
│ ┌─────────┐│          │ ┌─────────┐ │
│ │Entry    ││          │ │Entry    │ │
│ │K:V      ││          │ │K:V      │ │
│ └────┬────┘│          │ └────┬────┘ │
│      │      │          │      │      │
│      ↓      │          │      ↓      │
│ ┌─────────┐│          │ ┌─────────┐ │
│ │Entry    ││          │ │Entry    │ │
│ │K:V      ││          │ │K:V      │ │
│ └─────────┘│          │ └─────────┘ │
└─────────────┘          └─────────────┘
```

### 2.3 动态扩展机制

```
扩展前 (4个buckets):
┌───┬───┬───┬───┐
│ 0 │ 1 │ 2 │ 3 │  ← Buckets
└─┬─┴─┬─┴─┬─┴─┬─┘
  │   │   │   │
  ↓   ↓   ↓   ↓
Hash函数: h(key) % 4

扩展后 (8个buckets):
┌───┬───┬───┬───┬───┬───┬───┬───┐
│ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │
└─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┘
  │   │   │   │   │   │   │   │
  ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓
Hash函数: h(key) % 8

数据重分布:
旧Bucket 0 → 新Bucket 0 或 4
旧Bucket 1 → 新Bucket 1 或 5
...

Linear Hashing技术:
✅ 渐进式扩展 (一次扩展一个bucket)
✅ 不需要全表rehash
✅ 减少扩展时的阻塞
```

### 2.4 冲突解决

```
链地址法 (Chaining):
Bucket 2:
  │
  ↓
┌──────────┐    ┌──────────┐    ┌──────────┐
│Entry: K1 │ →  │Entry: K5 │ →  │Entry: K9 │ → NULL
│     V1   │    │     V5   │    │     V9   │
└──────────┘    └──────────┘    └──────────┘

hash(K1) % 8 = 2
hash(K5) % 8 = 2  ← 冲突
hash(K9) % 8 = 2  ← 冲突

查找: 遍历链表，比较键值
时间复杂度: O(1 + α)，α是装载因子
```

### 2.5 应用场景

**Buffer Hash Table**:
```c
/* 根据BufferTag查找Buffer */
typedef struct BufferTag {
    RelFileNode rnode;    /* 表空间/数据库/关系 */
    ForkNumber forkNum;   /* Fork类型 */
    BlockNumber blockNum; /* 块号 */
} BufferTag;

/* 哈希表存储: BufferTag → Buffer ID */
BufferDesc *buf = hash_search(SharedBufHash, &tag, HASH_FIND, NULL);
```

**Lock Hash Table**:
```c
/* 根据锁对象查找锁 */
typedef struct LOCKTAG {
    uint32 locktag_field1;  /* 数据库OID */
    uint32 locktag_field2;  /* 关系OID */
    uint32 locktag_field3;  /* 块号/元组号 */
    uint16 locktag_field4;
    uint8  locktag_type;    /* 锁类型 */
} LOCKTAG;

LOCK *lock = hash_search(LockMethodLockHash, &tag, HASH_ENTER, &found);
```

---

## 3. 共享内存池

### 3.1 共享内存布局

```
Shared Memory全景图:
┌─────────────────────────────────────────────────────┐
│              PostgreSQL Shared Memory               │
├─────────────────────────────────────────────────────┤
│  ┌───────────────────────────────────────────────┐ │
│  │          Shared Buffer Pool                   │ │  ← 最大部分
│  │  (shared_buffers = 8GB)                       │ │
│  │  ┌─────────────────────────────────────────┐ │ │
│  │  │ Buffer Descriptors                      │ │ │
│  │  │  ┌──────────┬──────────┬──────────┐    │ │ │
│  │  │  │ BufDesc0 │ BufDesc1 │  ...     │    │ │ │
│  │  │  └──────────┴──────────┴──────────┘    │ │ │
│  │  ├─────────────────────────────────────────┤ │ │
│  │  │ Buffer Data (8KB pages)                 │ │ │
│  │  │  ┌────────┬────────┬────────┬────────┐ │ │ │
│  │  │  │Page 0  │Page 1  │Page 2  │ ...    │ │ │ │
│  │  │  └────────┴────────┴────────┴────────┘ │ │ │
│  │  └─────────────────────────────────────────┘ │ │
│  └───────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────┤
│  ┌───────────────────────────────────────────────┐ │
│  │          Lock Manager Tables                  │ │
│  │  - LOCK hash table                            │ │
│  │  - PROCLOCK hash table                        │ │
│  └───────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────┤
│  ┌───────────────────────────────────────────────┐ │
│  │          WAL Insert Locks                     │ │
│  │  (WAL写入的LWLock)                            │ │
│  └───────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────┤
│  ┌───────────────────────────────────────────────┐ │
│  │          CLOG (Transaction Status)            │ │
│  │  (事务提交状态缓存)                           │ │
│  └───────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────┤
│  ┌───────────────────────────────────────────────┐ │
│  │          Proc Array (PGPROC)                  │ │
│  │  (所有进程的信息)                             │ │
│  └───────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────┘

内存分配方式:
Postmaster启动时: shmget() + shmat()
所有进程共享同一块物理内存
```

### 3.2 Buffer Descriptor结构

```
BufferDesc (缓冲区描述符):
┌──────────────────────────────────────────────────┐
│  BufferTag tag                                   │
│    ┌──────────────────────────────────────────┐ │
│    │ rnode:     (spcNode, dbNode, relNode)    │ │
│    │ forkNum:   main/fsm/vm/init              │ │
│    │ blockNum:  块号                          │ │
│    └──────────────────────────────────────────┘ │
├──────────────────────────────────────────────────┤
│  int buf_id                  ← Buffer ID        │
│  int freeNext                ← 空闲链表指针     │
│  LWLock content_lock         ← 内容锁           │
│  uint32 usage_count          ← Clock-Sweep计数  │
│  uint16 flags                ← 状态标志         │
│     - BM_DIRTY: 脏页                            │
│     - BM_VALID: 有效                            │
│     - BM_IO_IN_PROGRESS: I/O中                  │
└──────────────────────────────────────────────────┘
```

### 3.3 并发访问控制

```
多进程访问Buffer Pool:
┌──────────┐  ┌──────────┐  ┌──────────┐
│Backend 1 │  │Backend 2 │  │Backend 3 │
└────┬─────┘  └────┬─────┘  └────┬─────┘
     │             │             │
     └─────────────┼─────────────┘
                   ↓
        需要同步访问共享内存
                   │
     ┌─────────────┴─────────────┐
     ↓                           ↓
┌──────────┐              ┌──────────┐
│Spinlock  │              │ LWLock   │
│(短时间锁) │              │(长时间锁) │
└──────────┘              └──────────┘
     │                           │
     ↓                           ↓
保护哈希表操作            保护Buffer内容

锁层级:
Spinlock (最轻量)
  → 保护BufFreelistLock
  → 保护BufMappingLock partition

LWLock (轻量锁)
  → 保护Buffer content
  → 支持共享/排他模式
  → 允许睡眠等待
```

---

## 4. Clock-Sweep缓存

### 4.1 为什么不用LRU？

**LRU问题**:
```
┌──────────────────────────────────┐
│       LRU List                   │
│  ┌────┐  ┌────┐  ┌────┐  ┌────┐│
│  │MRU │→ │    │→ │    │→ │LRU ││
│  └────┘  └────┘  └────┘  └────┘│
└──────────────────────────────────┘

每次访问都要:
1. 移除节点
2. 移动到MRU端
3. 更新指针

高并发下:
❌ 需要加锁保护链表
❌ 锁竞争严重
❌ 性能瓶颈
```

### 4.2 Clock-Sweep算法

```
Clock-Sweep (类LRU，但无需维护链表):
            nextVictim
                ↓
        ┌───────────────┐
    ┌──→│  Buffer 0     │──┐
    │   │  usage=2      │  │
    │   ├───────────────┤  │
    │   │  Buffer 1     │  │
    │   │  usage=0      │←─┘ 环形数组
    │   ├───────────────┤
    └───│  Buffer 2     │
        │  usage=1      │
        ├───────────────┤
        │  Buffer 3     │
        │  usage=3      │
        └───────────────┘

算法:
1. nextVictim指针顺序扫描
2. 如果usage_count > 0: 递减，继续
3. 如果usage_count = 0: 淘汰此buffer

访问buffer时:
- usage_count++ (最大值5)

优点:
✅ 无需维护链表
✅ 无需全局锁
✅ 近似LRU效果
✅ 适合高并发
```

### 4.3 Clock-Sweep实现

```c
/* src/backend/storage/buffer/freelist.c */
Buffer
StrategyGetBuffer(BufferAccessStrategy strategy)
{
    BufferDesc *buf;
    int trycounter = NBuffers;  /* 最多扫描一圈 */

    for (;;)
    {
        buf = GetBufferDescriptor(StrategySyncStart);
        
        if (buf->usage_count == 0)
        {
            /* 找到victim, 淘汰此buffer */
            return BufferDescriptorGetBuffer(buf);
        }
        else
        {
            /* 递减usage_count */
            buf->usage_count--;
        }

        /* 移动clock hand */
        if (++StrategySyncStart >= NBuffers)
            StrategySyncStart = 0;

        if (--trycounter == 0)
            ereport(ERROR, ...);  /* 扫描一圈未找到 */
    }
}
```

### 4.4 Hot vs Cold数据

```
usage_count反映热度:
┌─────────────────────────────────────────────┐
│ Buffer   │ usage_count │  Status            │
├──────────┼─────────────┼────────────────────┤
│ Buffer 1 │      5      │  极热 (频繁访问)   │
│ Buffer 2 │      4      │  很热               │
│ Buffer 3 │      2      │  温热               │
│ Buffer 4 │      1      │  冷                 │
│ Buffer 5 │      0      │  极冷 (待淘汰)      │
└─────────────────────────────────────────────┘

访问模式:
热数据: usage_count保持高位 → 不会被淘汰
冷数据: usage_count快速递减到0 → 优先淘汰

自适应:
- 频繁访问的数据自动升温
- 不访问的数据自动降温
- 无需人工干预
```

---

## 5. 链表和双向链表

### 5.1 PostgreSQL中的链表应用

**单链表 (SList)**:
```c
typedef struct slist_node {
    struct slist_node *next;
} slist_node;

typedef struct {
    slist_node *head;
} slist_head;

应用场景: 简单的LIFO栈
┌─────┐    ┌─────┐    ┌─────┐
│Node1│ →  │Node2│ →  │Node3│ → NULL
└─────┘    └─────┘    └─────┘
```

**双向链表 (DList)**:
```c
typedef struct dlist_node {
    struct dlist_node *prev;
    struct dlist_node *next;
} dlist_node;

typedef struct {
    dlist_node *head;
    dlist_node *tail;
} dlist_head;

应用场景: 需要双向遍历
        ┌─────┐    ┌─────┐    ┌─────┐
NULL ← │Node1│ ↔  │Node2│ ↔  │Node3│ → NULL
        └─────┘    └─────┘    └─────┘
```

### 5.2 实际应用：MVCC版本链

```
Tuple版本链 (使用t_ctid连接):
┌──────────────────────┐
│ Tuple V1 (xid=100)   │
│ t_xmin = 100         │
│ t_xmax = 101         │
│ t_ctid = (page, off) │──┐
└──────────────────────┘  │
                          ↓
        ┌──────────────────────┐
        │ Tuple V2 (xid=101)   │
        │ t_xmin = 101         │
        │ t_xmax = 102         │
        │ t_ctid = (page, off) │──┐
        └──────────────────────┘  │
                                  ↓
                ┌──────────────────────┐
                │ Tuple V3 (xid=102)   │
                │ t_xmin = 102         │
                │ t_xmax = 0           │ ← 最新版本
                │ t_ctid = self        │
                └──────────────────────┘

遍历:
- 顺着t_ctid链向下找最新版本
- 根据快照判断可见性
```

### 5.3 Free List (空闲链表)

```
Buffer Free List:
┌────────────────────────────────────────┐
│ FreeListHead                           │
└───┬────────────────────────────────────┘
    │
    ↓
┌──────────┐    ┌──────────┐    ┌──────────┐
│ Buffer 5 │ →  │ Buffer 3 │ →  │ Buffer 9 │ → NULL
│ (free)   │    │ (free)   │    │ (free)   │
└──────────┘    └──────────┘    └──────────┘

操作:
- 申请Buffer: 从Head移除
- 释放Buffer: 插入Head (LIFO)

优点:
✅ O(1)时间分配/释放
✅ 缓存友好 (最近释放的先复用)
```

---

## 6. 位图集合 (Bitmapset)

### 6.1 Bitmapset结构

```
Bitmapset内存布局:
┌──────────────────────────────────────────────────┐
│ Bitmapset                                        │
│  ┌────────────────────────────────────────────┐ │
│  │ nwords: 2  (使用的word数)                  │ │
│  └────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────┐ │
│  │ words[0]:                                  │ │
│  │  01101001 01001101 00110101 10010110      │ │
│  │  (32 bits或64 bits，取决于平台)           │ │
│  └────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────┐ │
│  │ words[1]:                                  │ │
│  │  11010010 10110100 01101010 01101101      │ │
│  └────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────┘

每个bit代表一个元素:
bit 0 = 1 → 元素0存在
bit 1 = 0 → 元素1不存在
bit 2 = 1 → 元素2存在
...
```

### 6.2 应用场景：查询优化

```
示例: 表关系集合
Query: SELECT * FROM t1, t2, t3 WHERE ...

Planner需要跟踪哪些表已经join:
┌──────────────────────────────────────┐
│ RelOptInfo                           │
│  ┌────────────────────────────────┐ │
│  │ relids (Bitmapset):            │ │
│  │  bit 1: t1                     │ │
│  │  bit 2: t2                     │ │
│  │  bit 3: t3                     │ │
│  │  ...                           │ │
│  └────────────────────────────────┘ │
└──────────────────────────────────────┘

操作:
bms_add_member(set, 1);    // 添加t1
bms_add_member(set, 3);    // 添加t3
bms_is_member(2, set);     // 检查t2是否在集合中
bms_union(set1, set2);     // 集合并集
bms_intersect(set1, set2); // 集合交集
```

### 6.3 位运算优化

```c
/* 检查bit是否设置 */
bool
bms_is_member(int x, const Bitmapset *a)
{
    int wordnum = WORDNUM(x);  /* x / BITS_PER_WORD */
    int bitnum = BITNUM(x);    /* x % BITS_PER_WORD */

    if (wordnum >= a->nwords)
        return false;
    
    return (a->words[wordnum] & ((bitmapword) 1 << bitnum)) != 0;
}

/* 优点: */
✅ O(1)时间检查成员
✅ 紧凑存储 (1 bit per element)
✅ 位运算极快
✅ 支持集合操作 (并/交/差)
```

### 6.4 对比其他数据结构

| 操作 | Bitmapset | 哈希表 | 链表 |
|-----|-----------|--------|------|
| 查找 | O(1) | O(1) | O(n) |
| 插入 | O(1) | O(1) | O(1) |
| 空间 | n bits | n*size | n*size |
| 并集 | O(n/64) | O(n) | O(n²) |
| 交集 | O(n/64) | O(n) | O(n²) |

**使用建议**:
- 元素是小整数 → Bitmapset ✅
- 元素是字符串/复杂对象 → 哈希表
- 需要频繁插入/删除中间元素 → 链表

---

## 7. 设计原则总结

### 原则1: 根据访问模式选择数据结构

```
顺序访问 → 数组
随机访问 → 哈希表
范围查询 → B+树
集合操作 → Bitmapset
LIFO → 栈/单链表
FIFO → 队列
LRU → Clock-Sweep
```

### 原则2: 空间与时间的权衡

```
B+树: 空间↑ (索引开销) → 时间↓ (快速查找)
哈希表: 空间↑ (预留空间) → 时间↓ (O(1)查找)
Bitmapset: 空间↓ (紧凑) → 时间↓ (位运算快)
```

### 原则3: 缓存友好

```
✅ 数组 (连续内存，缓存友好)
✅ B+树 (一个节点多个键，局部性好)
❌ 链表 (指针跳转，缓存不友好)
❌ 深层嵌套结构
```

### 原则4: 并发友好

```
✅ Clock-Sweep (无需全局链表锁)
✅ 分区哈希表 (减少锁竞争)
✅ 无锁数据结构 (CAS操作)
❌ 全局链表 (需要锁保护)
```

### 原则5: 渐进式扩展

```
✅ 动态哈希 (Linear Hashing)
✅ B+树分裂 (逐步分裂)
❌ 全表rehash (一次性代价大)
```

---

## 总结

### PostgreSQL中的经典数据结构

1. **B+树** - 磁盘索引首选
2. **动态哈希表** - 内存查找利器
3. **共享内存池** - 多进程协作基础
4. **Clock-Sweep** - 高效缓存淘汰
5. **链表** - 简单通用
6. **Bitmapset** - 紧凑集合表示

### 通用设计原则

- ✅ 选择合适的数据结构比优化算法更重要
- ✅ 减少I/O是性能优化的第一原则
- ✅ 并发友好设计至关重要
- ✅ 空间与时间需要权衡
- ✅ 实测比理论分析更可靠

### 下一步

阅读 [03_algorithms.md](03_algorithms.md) 学习PostgreSQL中的算法设计！

---

**版本**: PostgreSQL 17.6  
**最后更新**: 2025-10-17

