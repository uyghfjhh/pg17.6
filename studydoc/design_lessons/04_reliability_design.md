# 可靠性设计

> 从PostgreSQL学习如何构建永不宕机的系统

**版本**: PostgreSQL 17.6  
**最后更新**: 2025-10-17

---

## 目录

1. [WAL日志保证崩溃恢复](#1-wal日志保证崩溃恢复)
2. [Checkpoint机制](#2-checkpoint机制)
3. [数据校验](#3-数据校验)
4. [故障检测与恢复](#4-故障检测与恢复)
5. [备份策略](#5-备份策略)
6. [可靠性设计原则](#6-可靠性设计原则)

---

## 1. WAL日志保证崩溃恢复

### 1.1 WAL三大保证

```
保证1: 持久性 (Durability)
┌──────────────────────────────┐
│ COMMIT后数据必须持久化        │
│ 方法: WAL先于数据刷盘         │
└──────────────────────────────┘

保证2: 原子性 (Atomicity)
┌──────────────────────────────┐
│ 事务要么全部完成要么全部回滚   │
│ 方法: WAL记录完整事务操作     │
└──────────────────────────────┘

保证3: 崩溃恢复
┌──────────────────────────────┐
│ 崩溃后能恢复到一致状态         │
│ 方法: 重放WAL日志             │
└──────────────────────────────┘
```

### 1.2 WAL写入流程

```
关键路径:
┌────────────────────────────────┐
│ 1. Backend修改页面              │
│    page->lsn = current_lsn     │
└───────┬────────────────────────┘
        ↓
┌────────────────────────────────┐
│ 2. 生成WAL Record              │
│    XLogInsert(...)             │
└───────┬────────────────────────┘
        ↓
┌────────────────────────────────┐
│ 3. COMMIT时fsync WAL           │
│    XLogFlush(lsn)              │
│    → 等待磁盘确认              │
└───────┬────────────────────────┘
        ↓
┌────────────────────────────────┐
│ 4. 返回COMMIT成功              │
└────────────────────────────────┘

关键: 只有WAL刷盘成功，COMMIT才能返回
```

### 1.3 崩溃恢复示例

```
场景: 数据库崩溃

恢复前状态:
┌──────────────────────────────┐
│ WAL:                         │
│  - Record1: INSERT id=1      │
│  - Record2: COMMIT (已刷盘)  │
│  - Record3: UPDATE id=1      │
│  - Record4: COMMIT (已刷盘)  │
│  - Record5: DELETE id=2      │
│  - (未COMMIT) ← 崩溃         │
└──────────────────────────────┘
┌──────────────────────────────┐
│ 数据文件:                     │
│  - id=1 (旧值) ← 未刷盘      │
│  - id=2 存在                 │
└──────────────────────────────┘

恢复流程:
1. 读取Checkpoint
2. 重放WAL:
   - Redo: INSERT id=1 ✅
   - Redo: UPDATE id=1 ✅
   - Undo: DELETE id=2 ✅ (回滚未提交事务)

恢复后状态:
┌──────────────────────────────┐
│ 数据文件:                     │
│  - id=1 (新值) ✅            │
│  - id=2 存在 ✅              │
└──────────────────────────────┘
```

---

## 2. Checkpoint机制

### 2.1 Checkpoint目的

```
目的1: 减少恢复时间
┌─────────────────────────────────┐
│ 无Checkpoint: 从头重放所有WAL    │
│ 有Checkpoint: 只重放最近的WAL    │
└─────────────────────────────────┘

目的2: 控制WAL大小
┌─────────────────────────────────┐
│ Checkpoint后可以删除旧WAL        │
└─────────────────────────────────┘
```

### 2.2 Checkpoint流程

```
Checkpoint执行:
┌────────────────────────────────┐
│ 1. 记录Checkpoint开始位置       │
│    checkpoint_lsn = GetInsertRecPtr() │
└───────┬────────────────────────┘
        ↓
┌────────────────────────────────┐
│ 2. 刷新所有Dirty Pages          │
│    for each dirty page:        │
│      fsync(page)               │
└───────┬────────────────────────┘
        ↓
┌────────────────────────────────┐
│ 3. 更新pg_control文件           │
│    写入checkpoint_lsn          │
└───────┬────────────────────────┘
        ↓
┌────────────────────────────────┐
│ 4. 删除旧WAL文件                │
└────────────────────────────────┘
```

### 2.3 Checkpoint调优

```
问题: Checkpoint导致I/O峰值

参数调优:
checkpoint_timeout = 15min        # 间隔时间
max_wal_size = 4GB               # WAL大小阈值
checkpoint_completion_target = 0.9 # 分散I/O

效果对比:
┌───────────────────────────────┐
│ completion_target = 0.1       │
│ I/O: ████████░░░░░░░░░░       │ ← I/O峰值
└───────────────────────────────┘
┌───────────────────────────────┐
│ completion_target = 0.9       │
│ I/O: ██████████████████░░     │ ← I/O平滑
└───────────────────────────────┘
```

---

## 3. 数据校验

### 3.1 Page Checksum

```
Page Header:
┌──────────────────────────────┐
│ pd_lsn: WAL位置               │
│ pd_checksum: 校验和 ← 重点！  │
│ pd_flags: 标志                │
│ ...                          │
└──────────────────────────────┘

计算checksum:
uint16 checksum = pg_checksum_page(page, blockno);

验证:
if (page->pd_checksum != expected_checksum)
    ereport(ERROR, "page verification failed");
```

### 3.2 WAL Checksum

```
WAL Record:
┌──────────────────────────────┐
│ xl_tot_len: 记录总长度        │
│ xl_xid: 事务ID                │
│ xl_prev: 前一条记录           │
│ xl_crc: CRC校验和 ← 重点！    │
│ data: 实际数据                │
└──────────────────────────────┘

作用:
✅ 检测磁盘错误
✅ 检测内存错误
✅ 检测传输错误
```

---

## 4. 故障检测与恢复

### 4.1 进程崩溃检测

```
Postmaster监控机制:
┌────────────────────────────────┐
│ 1. SIGCHLD信号                 │
│    子进程退出时触发             │
└───────┬────────────────────────┘
        ↓
┌────────────────────────────────┐
│ 2. 判断退出原因                │
│    - 正常退出: OK              │
│    - 异常退出: 崩溃!           │
└───────┬────────────────────────┘
        ↓
┌────────────────────────────────┐
│ 3. 崩溃恢复流程                │
│    - 终止所有Backend            │
│    - 启动Recovery              │
│    - 重放WAL                   │
│    - 恢复服务                  │
└────────────────────────────────┘
```

### 4.2 自动故障转移

```
主从架构:
┌──────────┐     WAL       ┌──────────┐
│  Primary │ ──Stream──→   │ Standby  │
│  (主库)  │               │  (从库)  │
└──────────┘               └──────────┘
     ↓ 崩溃
     ✗

自动Failover:
┌──────────┐
│ Standby  │ ← 提升为Primary
│ (新主库) │
└──────────┘

工具: Patroni, repmgr, pg_auto_failover
```

---

## 5. 备份策略

### 5.1 物理备份

```
pg_basebackup:
┌────────────────────────────────┐
│ 1. 发起备份请求                │
│    pg_basebackup -D backup/    │
└───────┬────────────────────────┘
        ↓
┌────────────────────────────────┐
│ 2. 创建备份开始Checkpoint       │
└───────┬────────────────────────┘
        ↓
┌────────────────────────────────┐
│ 3. 复制所有数据文件             │
│    (在线备份，不影响服务)       │
└───────┬────────────────────────┘
        ↓
┌────────────────────────────────┐
│ 4. 备份WAL归档文件              │
└────────────────────────────────┘
```

### 5.2 PITR (时间点恢复)

```
场景: 误删除数据，需要恢复到删除前

恢复流程:
┌────────────────────────────────┐
│ 1. 停止数据库                   │
└───────┬────────────────────────┘
        ↓
┌────────────────────────────────┐
│ 2. 恢复base backup              │
│    cp -r backup/* data/         │
└───────┬────────────────────────┘
        ↓
┌────────────────────────────────┐
│ 3. 配置recovery.conf            │
│    recovery_target_time =      │
│      '2025-10-17 10:00:00'     │
└───────┬────────────────────────┘
        ↓
┌────────────────────────────────┐
│ 4. 启动数据库，自动恢复到目标点 │
└────────────────────────────────┘
```

### 5.3 备份策略建议

```
3-2-1规则:
┌────────────────────────────────┐
│ 3份数据副本                     │
│ 2种不同存储介质                 │
│ 1份异地备份                     │
└────────────────────────────────┘

备份频率:
- 全量备份: 每周
- 增量备份: 每天
- WAL归档: 实时
- 备份保留: 30天

验证:
✅ 定期恢复测试
✅ 监控备份成功率
✅ 验证备份完整性
```

---

## 6. 可靠性设计原则

### 原则1: 防御性编程

```c
/* 永远验证输入 */
if (buffer == NULL)
    elog(ERROR, "invalid buffer pointer");

/* 使用断言 */
Assert(TransactionIdIsValid(xid));

/* 错误处理 */
PG_TRY();
{
    // 危险操作
}
PG_CATCH();
{
    // 清理资源
    PG_RE_THROW();
}
PG_END_TRY();
```

### 原则2: 故障隔离

```
隔离层级:
┌────────────────────────────────┐
│ 进程隔离                        │
│  一个进程崩溃不影响其他         │
└────────────────────────────────┘
┌────────────────────────────────┐
│ 事务隔离                        │
│  事务回滚不影响已提交事务       │
└────────────────────────────────┘
┌────────────────────────────────┐
│ 数据隔离                        │
│  损坏的页面不影响其他页面       │
└────────────────────────────────┘
```

### 原则3: 快速失败

```
理念: 尽早发现问题，避免级联故障

示例:
// ❌ 坏: 静默失败
if (buffer == NULL)
    return NULL;  // 问题被隐藏

// ✅ 好: 快速失败
if (buffer == NULL)
    elog(ERROR, "buffer is NULL");  // 立即报错
```

### 原则4: 可观测性

```
日志级别:
DEBUG   - 调试信息
LOG     - 正常操作日志
WARNING - 警告信息
ERROR   - 错误（事务回滚）
PANIC   - 严重错误（数据库停止）

监控指标:
✅ 崩溃次数
✅ WAL写入速度
✅ Checkpoint频率
✅ 备份成功率
```

---

## 总结

### 可靠性保证机制

1. **WAL** - 崩溃恢复的基石
2. **Checkpoint** - 控制恢复时间
3. **Checksum** - 数据完整性验证
4. **进程隔离** - 故障不扩散
5. **备份** - 最后一道防线

### 设计原则

- ✅ Write-Ahead Logging
- ✅ 防御性编程
- ✅ 故障隔离
- ✅ 快速失败
- ✅ 可观测性

---

**下一步**: 阅读 [05_consistency_design.md](05_consistency_design.md)

**版本**: PostgreSQL 17.6  
**最后更新**: 2025-10-17

