# 算法设计精华

> 从PostgreSQL学习经典算法的工程实现

**版本**: PostgreSQL 17.6  
**最后更新**: 2025-10-17

---

## 目录

1. [死锁检测算法](#1-死锁检测算法)
2. [查询优化算法](#2-查询优化算法)
3. [Clock-Sweep缓存淘汰](#3-clock-sweep缓存淘汰)
4. [VACUUM清理算法](#4-vacuum清理算法)
5. [两阶段提交2PC](#5-两阶段提交2pc)
6. [快照隔离算法](#6-快照隔离算法)

---

## 1. 死锁检测算法

### 1.1 问题场景

```
Transaction 1                 Transaction 2
    │                             │
    │ LOCK(A)  ✅                 │
    │                             │ LOCK(B)  ✅
    │                             │
    │ 想要LOCK(B) ⏳              │
    │ (等待T2释放B)               │
    │                             │ 想要LOCK(A) ⏳
    │                             │ (等待T1释放A)
    ↓                             ↓
  形成死锁！                     形成死锁！
```

### 1.2 等待图 (Wait-For Graph)

```
等待图表示:
┌────┐        ┌────┐
│ T1 │───────>│ T2 │   T1等待T2持有的锁
└────┘        └────┘
  ↑             │
  │             │
  └─────────────┘   T2等待T1持有的锁
    形成环→死锁！

多个事务的复杂情况:
    ┌────┐
    │ T1 │────┐
    └────┘    │
      ↑       ↓
      │     ┌────┐
      │     │ T2 │
      │     └────┘
      │       │
      │       ↓
    ┌────┐  ┌────┐
    │ T4 │<─│ T3 │
    └────┘  └────┘
    
检测环: T1→T2→T3→T4→T1
```

### 1.3 深度优先搜索 (DFS) 检测环

```c
/* 死锁检测伪代码 */
bool DeadLockCheck(PGPROC *proc)
{
    static bool visited[MAX_BACKENDS];
    static bool onStack[MAX_BACKENDS];
    
    visited[proc->pgprocno] = true;
    onStack[proc->pgprocno] = true;  // 标记在当前路径上
    
    // 遍历所有proc等待的进程
    for (each waitingProc in proc->waitQueue) {
        if (!visited[waitingProc]) {
            if (DeadLockCheck(waitingProc))
                return true;  // 发现环
        }
        else if (onStack[waitingProc]) {
            return true;  // 发现环：访问到路径上的节点
        }
    }
    
    onStack[proc->pgprocno] = false;  // 回溯
    return false;
}

检测流程:
1. 从每个等待的进程开始DFS
2. 标记visited和onStack
3. 如果访问到onStack中的节点→发现环
4. 选择一个victim中止，打破死锁
```

### 1.4 死锁检测时机

```
PostgreSQL策略:
┌─────────────────────────────────────────────────┐
│ 1. 进程开始等待锁                                │
│    ↓                                            │
│ 2. 启动定时器 (deadlock_timeout = 1s)          │
│    ↓                                            │
│ 3. 1秒后仍在等待 → 触发死锁检测                 │
│    ↓                                            │
│ 4. 运行DFS算法                                  │
│    ↓                                            │
│ 5. 如果发现死锁 → 中止当前事务                   │
│    如果没有死锁 → 继续等待                       │
└─────────────────────────────────────────────────┘

优点:
✅ 避免频繁检测 (1秒足够区分死锁vs短暂等待)
✅ DFS算法高效 O(V+E)
```

---

## 2. 查询优化算法

### 2.1 Join顺序优化问题

```
查询: SELECT * FROM T1, T2, T3 WHERE ...

可能的Join顺序:
1. (T1 JOIN T2) JOIN T3
2. (T1 JOIN T3) JOIN T2
3. (T2 JOIN T3) JOIN T1
4. ...

n个表有 (2n-2)!/(n-1)! 种顺序
3表: 12种
4表: 120种
10表: 17亿种！ ← 暴力穷举不可行
```

### 2.2 动态规划算法

```
动态规划求解:
┌─────────────────────────────────────────────────┐
│ 自底向上构建最优计划                             │
├─────────────────────────────────────────────────┤
│ Level 1: 单表访问路径                            │
│  ┌────┐  ┌────┐  ┌────┐                         │
│  │ T1 │  │ T2 │  │ T3 │                         │
│  └────┘  └────┘  └────┘                         │
│   cost    cost    cost                           │
├─────────────────────────────────────────────────┤
│ Level 2: 两表Join                                │
│  ┌────────┐  ┌────────┐  ┌────────┐            │
│  │T1 JOIN │  │T1 JOIN │  │T2 JOIN │            │
│  │  T2    │  │  T3    │  │  T3    │            │
│  └────────┘  └────────┘  └────────┘            │
│   选最优     选最优       选最优                  │
├─────────────────────────────────────────────────┤
│ Level 3: 三表Join                                │
│  ┌──────────────────┐                           │
│  │ (T1 JOIN T2)     │                           │
│  │   JOIN T3        │                           │
│  └──────────────────┘                           │
│  基于Level 2的最优路径                           │
└─────────────────────────────────────────────────┘

时间复杂度: O(3^n) vs O(n!)
3表: 27 vs 6
4表: 81 vs 24
10表: 59,049 vs 3,628,800
```

### 2.3 代价估算

```
成本模型:
Cost = CPU_Cost + IO_Cost

┌─────────────────────────────────────────────────┐
│ SeqScan Cost:                                   │
│   cost = (pages * seq_page_cost) +             │
│          (tuples * cpu_tuple_cost)              │
├─────────────────────────────────────────────────┤
│ IndexScan Cost:                                 │
│   cost = (index_pages * random_page_cost) +    │
│          (tuples * cpu_index_tuple_cost) +     │
│          (heap_pages * random_page_cost)        │
├─────────────────────────────────────────────────┤
│ HashJoin Cost:                                  │
│   cost = (build_cost) +                         │
│          (probe_cost) +                         │
│          (hash_cost)                            │
└─────────────────────────────────────────────────┘

示例对比:
Table: 1,000,000 rows
      100,000 pages

SeqScan:  100,000 * 1.0 = 100,000
IndexScan: 10 * 4.0 (索引) + 100 * 4.0 (堆) = 440
→ 选择IndexScan
```

---

## 3. Clock-Sweep缓存淘汰

### 3.1 经典LRU的问题

```
问题: 扫描大表会污染缓存

场景: SELECT * FROM huge_table;

┌──────────────────────────────────────┐
│        Buffer Pool (Before)          │
│  ┌────┬────┬────┬────┬────┬────┐   │
│  │HOT │HOT │HOT │HOT │HOT │HOT │   │ ← 热数据
│  └────┴────┴────┴────┴────┴────┘   │
└──────────────────────────────────────┘
            ↓ 扫描大表
┌──────────────────────────────────────┐
│        Buffer Pool (After)           │
│  ┌────┬────┬────┬────┬────┬────┐   │
│  │COLD│COLD│COLD│COLD│COLD│COLD│   │ ← 冷数据覆盖!
│  └────┴────┴────┴────┴────┴────┘   │
└──────────────────────────────────────┘

LRU会把所有热数据淘汰！
```

### 3.2 Clock-Sweep改进

```
usage_count机制:
┌──────────────────────────────────────────────────┐
│ 访问buffer时:                                    │
│   usage_count = min(usage_count + 1, 5)          │
│                                                  │
│ 淘汰扫描时:                                      │
│   if (usage_count > 0)                           │
│       usage_count--;  // 递减                    │
│   else                                           │
│       淘汰此buffer;                              │
└──────────────────────────────────────────────────┘

效果:
热数据 (频繁访问)   → usage_count保持高位 → 不会被淘汰
冷数据 (扫描一次)   → usage_count=1 → 很快被淘汰
临时数据 (扫描表)   → usage_count低 → 优先淘汰

自适应学习:
✅ 热数据自动升温
✅ 冷数据自动降温
✅ 无需预配置
```

---

## 4. VACUUM清理算法

### 4.1 标记-清除算法

```
VACUUM两阶段:
┌─────────────────────────────────────────────────┐
│ Phase 1: 标记阶段 (Scan Heap)                    │
├─────────────────────────────────────────────────┤
│  扫描表的每一页:                                 │
│  for each page:                                 │
│    for each tuple:                              │
│      if tuple is dead:                          │
│        记录dead tuple的TID                      │
│        (存储在maintenance_work_mem中)           │
└─────────────────────────────────────────────────┘
            ↓
┌─────────────────────────────────────────────────┐
│ Phase 2: 清除阶段 (Cleanup)                      │
├─────────────────────────────────────────────────┤
│ 2.1 清理索引                                     │
│   for each index:                               │
│     删除指向dead tuple的索引项                   │
│                                                 │
│ 2.2 清理堆表                                     │
│   for each page:                                │
│     压缩页面，移除dead tuple                     │
│     更新FSM (Free Space Map)                    │
│                                                 │
│ 2.3 更新统计信息                                 │
│   更新pg_stat_user_tables                       │
└─────────────────────────────────────────────────┘
```

### 4.2 Dead Tuple判断

```
Tuple可见性判断:
┌──────────────────────────────────────────────────┐
│ bool HeapTupleIsDead(tuple):                     │
│                                                  │
│   if (t_xmin not committed):                    │
│       return false  // 插入事务未提交            │
│                                                  │
│   if (t_xmax not valid):                        │
│       return false  // 未被删除                  │
│                                                  │
│   if (t_xmax committed):                        │
│       if (no active snapshot can see tuple):    │
│           return true   // Dead!                │
│                                                  │
│   return false                                   │
└──────────────────────────────────────────────────┘

Dead条件:
✅ 插入事务已提交
✅ 删除事务已提交
✅ 没有任何活跃快照能看到此tuple
```

---

## 5. 两阶段提交 (2PC)

### 5.1 分布式事务问题

```
场景: 跨数据库转账
Database A: 账户余额 -100
Database B: 账户余额 +100

问题: 如何保证两个操作都成功或都失败？
┌──────────┐        ┌──────────┐
│  DB A    │        │  DB B    │
│  -100 ✅ │        │  +100 ❌ │ ← Crash!
└──────────┘        └──────────┘
结果: 数据不一致!
```

### 5.2 两阶段提交协议

```
2PC流程:
┌─────────────────────────────────────────────────┐
│ Phase 1: Prepare阶段                             │
├─────────────────────────────────────────────────┤
│  Coordinator                                    │
│      │                                          │
│      ├──PREPARE──→ DB A                         │
│      │                ↓                         │
│      │            写WAL: PREPARE                │
│      │                ↓                         │
│      │            返回: YES/NO                  │
│      │                                          │
│      ├──PREPARE──→ DB B                         │
│      │                ↓                         │
│      │            写WAL: PREPARE                │
│      │                ↓                         │
│      │            返回: YES/NO                  │
│      ↓                                          │
│  所有YES → Phase 2                              │
│  任何NO → ABORT                                 │
└─────────────────────────────────────────────────┘
            ↓
┌─────────────────────────────────────────────────┐
│ Phase 2: Commit阶段                              │
├─────────────────────────────────────────────────┤
│  Coordinator                                    │
│      │                                          │
│      ├──COMMIT──→ DB A                          │
│      │              ↓                           │
│      │          提交事务                         │
│      │              ↓                           │
│      │          返回: OK                        │
│      │                                          │
│      ├──COMMIT──→ DB B                          │
│      │              ↓                           │
│      │          提交事务                         │
│      │              ↓                           │
│      │          返回: OK                        │
│      ↓                                          │
│  全部完成                                        │
└─────────────────────────────────────────────────┘
```

### 5.3 崩溃恢复

```
崩溃场景及恢复:
┌─────────────────────────────────────────────────┐
│ 场景1: Prepare前崩溃                             │
│   → 简单回滚，无影响                             │
├─────────────────────────────────────────────────┤
│ 场景2: Prepare后，Commit前崩溃                   │
│   → 恢复时检查WAL                                │
│   → 如果有PREPARE记录，等待Coordinator指令      │
│   → 重新发送COMMIT/ABORT                         │
├─────────────────────────────────────────────────┤
│ 场景3: Commit后崩溃                              │
│   → 恢复时重放WAL                                │
│   → 事务已提交，数据一致                         │
└─────────────────────────────────────────────────┘

关键: WAL保证持久性!
```

---

## 6. 快照隔离算法

### 6.1 Snapshot生成

```
事务开始时获取快照:
┌──────────────────────────────────────────────────┐
│ Snapshot结构:                                    │
│  ┌────────────────────────────────────────────┐ │
│  │ xmin:  100  (最小活跃事务ID)               │ │
│  │ xmax:  110  (下一个将分配的XID)            │ │
│  │ xip:   [102, 105, 108]  (活跃事务列表)    │ │
│  │ xcnt:  3    (活跃事务数)                   │ │
│  └────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────┘

时间线:
    90  95  100 102 105 108  110  115
    ├───┼───┼───┼───┼───┼────┼────┤
    已提交  xmin  活跃事务  xmax  未分配
                    ↑
                  快照点
```

### 6.2 可见性判断算法

```c
bool HeapTupleSatisfiesMVCC(tuple, snapshot)
{
    // 规则1: tuple未插入
    if (t_xmin >= snapshot->xmax)
        return false;  // INVISIBLE
    
    // 规则2: tuple被回滚
    if (TransactionIdDidAbort(t_xmin))
        return false;  // INVISIBLE
    
    // 规则3: t_xmin在活跃事务中
    if (XidInMVCCSnapshot(t_xmin, snapshot))
        return false;  // INVISIBLE
    
    // 规则4: tuple已删除
    if (TransactionIdIsValid(t_xmax))
    {
        if (t_xmax < snapshot->xmax)  // 删除事务在快照前
        {
            if (!XidInMVCCSnapshot(t_xmax, snapshot))
                return false;  // INVISIBLE (已删除)
        }
    }
    
    return true;  // VISIBLE
}
```

### 6.3 可见性判断图示

```
示例场景:
Tuple: t_xmin=100, t_xmax=105
Snapshot: xmin=98, xmax=110, xip=[102,105,108]

判断流程:
┌─────────────────────────────────────────────────┐
│ 1. t_xmin=100 < xmax=110 ✅ (在快照范围内)      │
├─────────────────────────────────────────────────┤
│ 2. xmin in xip? 100 not in [102,105,108] ✅     │
│    → 插入事务已提交且在快照前                    │
├─────────────────────────────────────────────────┤
│ 3. t_xmax=105 in xip? 105 in [102,105,108] ✅   │
│    → 删除事务还在活跃中                          │
├─────────────────────────────────────────────────┤
│ 结论: VISIBLE (对当前快照可见)                   │
└─────────────────────────────────────────────────┘

不同快照看到不同版本:
    Snapshot A (早期)  → 看到旧版本
    Snapshot B (当前)  → 看到旧版本
    Snapshot C (未来)  → 看到新版本 (删除后)
```

---

## 总结

### 经典算法应用

1. **死锁检测** - DFS + 等待图
2. **查询优化** - 动态规划 + 代价估算
3. **缓存淘汰** - Clock-Sweep近似LRU
4. **VACUUM** - 标记-清除GC
5. **2PC** - 分布式一致性协议
6. **MVCC** - 快照隔离算法

### 设计原则

- ✅ 选择合适的算法比优化更重要
- ✅ 工程实现需要考虑实际约束
- ✅ 近似算法往往更实用 (Clock-Sweep)
- ✅ 组合多种算法解决复杂问题

---

**版本**: PostgreSQL 17.6  
**最后更新**: 2025-10-17
