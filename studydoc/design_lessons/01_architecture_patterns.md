# 架构模式和设计原则

> 从PostgreSQL学习系统架构设计的智慧

**版本**: PostgreSQL 17.6  
**最后更新**: 2025-10-17

---

## 目录

1. [进程架构 vs 线程架构](#1-进程架构-vs-线程架构)
2. [分层架构设计](#2-分层架构设计)
3. [MVCC架构](#3-mvcc架构)
4. [WAL日志架构](#4-wal日志架构)
5. [插件化架构](#5-插件化架构)
6. [设计原则总结](#6-设计原则总结)

---

## 1. 进程架构 vs 线程架构

### 1.1 PostgreSQL的选择：多进程架构

**架构图**:
```
                    Client Connections
                           ↓
                    ┌──────────────┐
                    │  Postmaster  │  ← 主进程 (守护进程)
                    │  (Port 5432) │
                    └──────┬───────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
        ↓                  ↓                  ↓
  ┌──────────┐      ┌──────────┐      ┌──────────┐
  │ Backend  │      │ Backend  │      │ Backend  │
  │ Process 1│      │ Process 2│      │ Process 3│
  └──────────┘      └──────────┘      └──────────┘
        │                  │                  │
        └──────────────────┼──────────────────┘
                           ↓
                  ┌─────────────────┐
                  │  Shared Memory  │  ← 共享缓冲池
                  │   (Buffers,     │
                  │    Locks, etc)  │
                  └─────────────────┘
                           ↑
        ┌──────────────────┼──────────────────┐
        │                  │                  │
        ↓                  ↓                  ↓
  ┌──────────┐      ┌──────────┐      ┌──────────┐
  │BGWriter  │      │WAL Writer│      │Autovacuum│
  └──────────┘      └──────────┘      └──────────┘
```

### 1.2 设计决策分析

**多进程架构优点**:
- ✅ **隔离性强** - 一个连接崩溃不影响其他
- ✅ **资源管理简单** - 进程结束自动回收资源
- ✅ **代码简单** - 无需复杂的锁同步

**多进程架构缺点**:
- ❌ **创建开销大** - fork()成本高（缓解：连接池）
- ❌ **内存占用多** - 每个进程独立栈

**MySQL线程架构对比**:
```
优点: 创建快，切换快，内存共享方便
缺点: 一个线程crash可能导致整个进程crash
```

---

## 2. 分层架构设计

### 2.1 PostgreSQL的五层架构

```
┌─────────────────────────────────────────┐
│         Client Layer (客户端)           │
└───────────────┬─────────────────────────┘
                ↓
┌─────────────────────────────────────────┐
│      Query Layer (查询层)               │
│  Parser → Rewriter → Planner            │
└───────────────┬─────────────────────────┘
                ↓
┌─────────────────────────────────────────┐
│      Executor Layer (执行层)            │
│  SeqScan/IndexScan/Join/Sort            │
└───────────────┬─────────────────────────┘
                ↓
┌─────────────────────────────────────────┐
│      Access Layer (访问层)              │
│  Heap/BTree/GiST Access Methods         │
└───────────────┬─────────────────────────┘
                ↓
┌─────────────────────────────────────────┐
│      Storage Layer (存储层)             │
│  Buffer/WAL/SMGR                        │
└─────────────────────────────────────────┘
```

### 2.2 分层设计原则

**原则1: 单向依赖**
```
上层依赖下层 ✅
下层不依赖上层 ✅
平级之间解耦 ✅
```

**原则2: 关注分离**
- Query Layer → SQL语义、优化
- Executor → 执行计划
- Access Layer → 数据访问
- Storage Layer → 缓冲、持久化

---

## 3. MVCC架构

### 3.1 MVCC核心思想

**传统锁模式 vs MVCC**:
```
传统锁:
Transaction 1: SELECT (获取共享锁) → 阻塞Transaction 2
Transaction 2: UPDATE (等待排他锁) → 等待...

MVCC:
Transaction 1: SELECT (读旧版本) → 不阻塞
Transaction 2: UPDATE (写新版本) → 同时进行

优点: 读写不阻塞，高并发
```

### 3.2 Tuple版本链

```
┌──────────────┐
│ Tuple V1     │  ← xmin=100, xmax=101, ctid→V2
│ (xid=100)    │
└──────┬───────┘
       ↓
┌──────────────┐
│ Tuple V2     │  ← xmin=101, xmax=0 (最新版本)
│ (xid=101)    │
└──────────────┘
```

---

## 4. WAL日志架构

### 4.1 Write-Ahead Logging

```
WAL写入流程:
┌────────────────────────────────┐
│ 1. 修改Shared Buffer            │
│    (Dirty Page)                │
└────────┬───────────────────────┘
         ↓
┌────────────────────────────────┐
│ 2. 写WAL记录到WAL Buffer        │
│    (LSN: Log Sequence Number)  │
└────────┬───────────────────────┘
         ↓
┌────────────────────────────────┐
│ 3. COMMIT时，等待WAL刷盘        │
│    (fsync)                     │
└────────────────────────────────┘

原则: 日志先于数据落盘
```

### 4.2 崩溃恢复

```
Recovery流程:
1. 读取Checkpoint位置
   ↓
2. 从Checkpoint重放WAL
   ↓
3. 重做所有已提交事务
   ↓
4. 回滚未提交事务
```

---

## 5. 插件化架构

### 5.1 Extensions系统

```
PostgreSQL核心:
┌─────────────────────────────────┐
│   Extension Hooks (钩子)        │
│   • planner_hook                │
│   • executor_hook               │
│   • object_access_hook          │
└───────────┬─────────────────────┘
            ↓
    ┌───────┴───────┐
    ↓               ↓
┌─────────┐   ┌─────────┐
│pg_stat_ │   │postgis  │
│statements│   │(空间)   │
└─────────┘   └─────────┘
```

### 5.2 钩子机制

```c
/* 全局钩子变量 */
planner_hook_type planner_hook = NULL;

PlannedStmt *planner(Query *parse, ...) {
    if (planner_hook)
        result = (*planner_hook)(parse, ...);
    else
        result = standard_planner(parse, ...);
    return result;
}

/* Extension注册钩子 */
void _PG_init(void) {
    planner_hook = my_planner_hook;
}
```

---

## 6. 设计原则总结

### 核心原则

1. **分层设计** - 关注分离，单向依赖
2. **隔离性优先** - 进程架构保证稳定性
3. **读写分离** - MVCC实现高并发
4. **Write-Ahead** - WAL保证持久性
5. **开放扩展** - 插件化架构
6. **模块化** - 高内聚低耦合

### 设计权衡

| 设计选择 | 优点 | 缺点 | PostgreSQL选择 |
|---------|-----|------|---------------|
| 进程 vs 线程 | 隔离性强 | 创建慢 | 进程+连接池 |
| MVCC vs 锁 | 读写不阻塞 | 需要VACUUM | MVCC |
| 同步 vs 异步 | 数据安全 | 性能较低 | 可配置 |

---

**下一步**: 阅读 [02_data_structures.md](02_data_structures.md)

**版本**: PostgreSQL 17.6  
**最后更新**: 2025-10-17

